<?xml version="1.0" encoding="UTF-8" ?><rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Aleahim.com</title><description></description><link>https://aleahim.com</link><atom:link
    href="https://aleahim.com/feed.rss"
    rel="self" type="application/rss+xml"
/><language>en</language><generator>Ignite v0.6.0</generator><image><url>/images/icon32.png</url><title>Aleahim.com</title><link>https://aleahim.com</link><width>32</width><height>32</height></image><item><guid isPermaLink="true">https://aleahim.com/ExtremePackagingOpenAPI</guid><title>From ExtremePackaging to OpenAPI Integration</title><link>https://aleahim.com/ExtremePackagingOpenAPI</link><description><![CDATA[When I first published ExtremePackaging, the goal was simple ‚Äî to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear.]]></description><pubDate>Tue, 23 Sep 2025 00:00:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljevic]]></dc:creator><category><![CDATA[[Swift]]></category><category><![CDATA[OpenAPI]]></category><category><![CDATA[ModularArchitecture]]></category><category><![CDATA[ExtremePackaging]]></category><category><![CDATA[Vapor]]></category><category><![CDATA[Middleware]]></category><category><![CDATA[YamlMerger]]]></category><content:encoded><![CDATA[<p>When I first published <a href="https://github.com/mihaelamj/ExtremePackaging">ExtremePackaging</a>, the goal was simple ‚Äî to prove that <strong>highly modular Swift architectures</strong> can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear.</p><p>But then came the next step: <em>Could this same architecture host a complete OpenAPI workflow ‚Äî with generated clients, servers, and full middleware integration ‚Äî without losing its elegance?</em></p><p>That‚Äôs how the new reference implementation, <strong>swift-openapi-extremepackaging-example</strong>, was born.</p><hr /><p>The original ExtremePackaging repository introduced a clean, layered structure:</p><ul><li><strong>Shared packages</strong> for models and protocols</li><li><strong>Independent feature modules</strong> for UI, data, and networking</li><li><strong>No cross-package leaks</strong></li><li><strong>Unified Xcode workspace</strong> that felt like a monolith but built like microservices</li></ul><p>The guiding philosophy: <em>Each feature should be an island, communicating only through well-defined contracts.</em></p><p>That foundation made it ideal for integrating OpenAPI-generated code ‚Äî which naturally fits into modular boundaries like <code>SharedApiModels</code>, <code>ApiClient</code>, and <code>ApiServer</code>.</p><hr /><h2>üöÄ Evolving Toward OpenAPI</h2><p>The OpenAPI version added an entire new layer of automation and functionality ‚Äî transforming a static architecture into a <strong>living, self-describing API ecosystem</strong>.</p><h3>1. OpenAPI Schema & Code Generation</h3><p>At the heart of the project is the <strong>OpenAPI specification (<code>openapi.yaml</code>)</strong> ‚Äî defining endpoints, models, and responses for a DummyJSON-compatible API.</p><p>Newly introduced elements:</p><ul><li>üß± Full schema definitions for <code>Users</code>, <code>Posts</code>, <code>Products</code>, <code>Todos</code>, and <code>Carts</code></li><li>üß© Error schemas (404, validation, authentication)</li><li>‚öôÔ∏è Integration with <strong>Swift OpenAPI Generator</strong></li><li>üîÅ Automatic generation of clients, models, and server stubs</li><li>üì¶ Separation of generated code into <code>SharedApiModels</code></li></ul><p>This turned the architecture into a self-contained API ecosystem ‚Äî one that can <strong>generate, serve, and consume</strong> its own endpoints.</p><hr /><h3>2. API Server Implementation</h3><p>A complete <strong>Vapor-based local server</strong> (<code>ApiServer</code>) was added to simulate real-world backend behavior:</p><ul><li>17 endpoints fully implemented from the OpenAPI spec</li><li>Realistic mock data mirroring DummyJSON</li><li>Pagination and validation logic</li><li>Centralized error responses</li><li>üñ•Ô∏è Prefixed logging for easy tracing in the console</li></ul><p>The server runs locally at <code>http://localhost:8080</code>, serving as both a mock backend and a test harness for the generated client.</p><hr /><h3>3. Enhanced API Client Architecture</h3><p>The client evolved from a simple abstraction into a <strong>fully concurrent, actor-based networking layer</strong>.</p><h4>Highlights</h4><ul><li><code>ApiClient</code> actor manages shared state safely across async contexts</li><li>Middleware chain introduced: <strong>Logging ‚Üí Authentication ‚Üí Correction</strong></li><li>Runtime environment switching between <code>.production</code>, <code>.local</code>, and <code>.mock</code></li><li>Shared singleton <code>ApiClientState</code> stores token, settings, and preferences</li></ul><p>Example flow:</p><pre><code class="language-swift">try await ApiClient.initializeShared(environment: .production)
let client = ApiClient.shared!
let auth = try await client.login(username: "emilys", password: "emilyspass")
await ApiClient.setToken(auth.accessToken)
let users = try await client.getUsers(limit: 10)
</code></pre><p>A clear separation between environment configuration and runtime state ensures deterministic, thread-safe behavior.</p><hr /><h3>4. Middleware Integration</h3><p>The client leverages two reusable middlewares from sibling packages:</p><ul><li><strong><a href="https://github.com/mihaelamj/OpenAPILoggingMiddleware">OpenAPILoggingMiddleware</a></strong><br />Provides structured, console + JSON logging with full request/response capture.</li><li><strong><a href="https://github.com/mihaelamj/BearerTokenAuthMiddleware">BearerTokenAuthMiddleware</a></strong><br />Manages JWT token injection with a concurrency-safe actor and public operation rules.</li></ul><p>Together, they demonstrate the power of <strong>middleware chaining</strong> in OpenAPI Runtime ‚Äî clean, modular extensions without inheritance or global state.</p><hr /><h3>5. YAMLMerger ‚Äî The Key to Structured API Specs</h3><p>The project uses <strong><a href="https://github.com/mihaelamj/YamlMerger">YamlMerger</a></strong> ‚Äî a Swift package that merges multiple YAML files into a single combined OpenAPI specification.<br />If your project doesn‚Äôt already include an <code>openapi.yaml</code>, YamlMerger ensures you have one ‚Äî and helps you maintain a <strong>structured, predictable folder layout</strong> under <code>Tests/</code> or <code>Sources/SharedApiModels/schemas/</code>.</p><h4>üß† Why It Must Be Copied into the Project</h4><p>YamlMerger cannot simply be added as a SwiftPM dependency for build-time merging because of <strong>SPM‚Äôs read-only resolution model</strong>:</p><ol><li>Swift Package Manager stores dependencies in a <strong>cached, read-only</strong> location (<code>.build/checkouts/</code>).</li><li>The OpenAPI generator, however, needs <strong>write access</strong> to output the merged <code>openapi.yaml</code> file directly into your source tree.</li><li>SPM build scripts are not allowed to write to source folders outside their sandboxed build directory.</li></ol><p>‚úÖ <strong>Solution:</strong> Copy the YamlMerger executable directly into your project (e.g. <code>Tools/YamlMerger/</code>) and call it from a pre-build script or CI pipeline.<br />This guarantees write permissions and makes the tool available to everyone checking out the repo.</p><h4>üß© What It Does</h4><p>YamlMerger scans subdirectories (01 ‚Üí 08) and merges YAML fragments in deterministic order:</p><ol><li>Folders are processed numerically.</li><li><code>__*.yaml</code> files merge first within each folder.</li><li>Remaining files merge alphabetically.</li><li>The final output is a complete OpenAPI spec, suitable for Swift OpenAPI Generator.</li></ol><h4>üß± Example Schema Layout</h4><pre><code>Schema/
‚îú‚îÄ‚îÄ 01_Info/
‚îú‚îÄ‚îÄ 02_Servers/
‚îú‚îÄ‚îÄ 03_Tags/
‚îú‚îÄ‚îÄ 04_Paths/
‚îú‚îÄ‚îÄ 05_Webhooks/
‚îú‚îÄ‚îÄ 06_Components/
‚îú‚îÄ‚îÄ 07_Security/
‚îî‚îÄ‚îÄ 08_ExternalDocs/
</code></pre><p>Each folder corresponds to a section of the OpenAPI spec, allowing multiple developers to work on different endpoints, schemas, or components without conflicts.</p><h4>‚öôÔ∏è Typical Workflow</h4><pre><code class="language-bash"># Merge schemas before build
./Tools/YamlMerger merge   --input Sources/SharedApiModels/schemas/   --output Sources/SharedApiModels/openapi.yaml
</code></pre><p>You can run this manually, in a pre-build phase, or as part of CI/CD automation.</p><h4>üí° Pro Tip</h4><p>If your project starts <strong>without</strong> an <code>openapi.yaml</code>, placing schema fragments in structured folders under <code>Tests/</code> ensures your API structure remains organized ‚Äî even before full code generation.<br />YamlMerger gives your tests (and your teammates) a <strong>shared, visual map</strong> of your API‚Äôs evolving shape.</p><hr /><h3>6. Test Coverage Expansion</h3><p>Two new test suites validate both local and production APIs:</p><ul><li>üß™ <code>ApiClientLocalTests.swift</code> ‚Äî 25 tests targeting the local Vapor server</li><li>üåê <code>ApiClientProductionTests.swift</code> ‚Äî 29 integration tests against DummyJSON API</li></ul><p>Tests cover:</p><ul><li>Authentication and token persistence</li><li>Pagination behavior</li><li>Error responses and invalid IDs</li><li>Concurrent request handling</li></ul><p>Together they form a <strong>54-test safety net</strong> proving both architecture and OpenAPI compliance.</p><hr /><h2>üß† Architecture Snapshot</h2><pre><code>Packages/
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îú‚îÄ‚îÄ ApiClient/
‚îÇ   ‚îú‚îÄ‚îÄ ApiServer/
‚îÇ   ‚îî‚îÄ‚îÄ SharedApiModels/
‚îî‚îÄ‚îÄ Tests/
    ‚îî‚îÄ‚îÄ ApiClientTests/
</code></pre><p>Each target is self-contained ‚Äî just like in the original ExtremePackaging ‚Äî but now with full OpenAPI integration, client/server symmetry, and end-to-end testability.</p><hr /><h2>‚ö° Key Improvements Over ExtremePackaging</h2><table class="table"><thead><th scope="col">Area</th><th scope="col">Before</th><th scope="col">After</th></thead><tbody><tr><td>API Definition</td><td>Manual protocol layer</td><td>Generated OpenAPI spec</td></tr><tr><td>Networking</td><td>Custom client</td><td>Actor-based client w/ middlewares</td></tr><tr><td>Server</td><td>None</td><td>Vapor mock server (17 endpoints)</td></tr><tr><td>Authentication</td><td>Static token</td><td>BearerTokenAuthMiddleware</td></tr><tr><td>Logging</td><td>Simple print logs</td><td>Structured OpenAPILoggingMiddleware</td></tr><tr><td>Testing</td><td>Minimal unit tests</td><td>Full integration tests (54 total)</td></tr><tr><td>Schema Management</td><td>Handwritten</td><td>Modular YAML + YamlMerger</td></tr><tr><td>Tooling</td><td>Swift only</td><td>Swift + OpenAPI toolchain</td></tr></tbody></table><hr /><h2>üß≠ Lessons Learned</h2><ol><li><strong>OpenAPI fits perfectly into modular Swift architectures</strong> ‚Äî generated code belongs in its own layer, and SwiftPM makes that separation effortless.</li><li><strong>Actors are the future of shared state</strong> ‚Äî simple, safe, and transparent.</li><li><strong>Middleware > Managers</strong> ‚Äî function composition scales better than class hierarchies.</li><li><strong>Automation beats documentation</strong> ‚Äî with OpenAPI, the spec <em>is</em> the documentation.</li></ol><hr /><h2>üí¨ Closing Thoughts</h2><p>This evolution of ExtremePackaging into a full OpenAPI reference app is more than a demo ‚Äî it‚Äôs a <strong>blueprint for modular API-driven development in Swift</strong>.</p><p>From YAML schemas to live servers and typed clients, everything now exists in one unified, testable ecosystem ‚Äî powered by Apple‚Äôs official OpenAPI tools and guided by the ExtremePackaging philosophy.</p><p>üëâ Explore the project: <a href="https://github.com/mihaelamj/swift-openapi-extremepackaging-example">swift-openapi-extremepackaging-example</a></p><hr /><p><em>‚ÄúArchitecture should scale not by adding layers, but by removing assumptions.‚Äù</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://aleahim.com/LoggingMiddleware</guid><title>Introducing OpenAPILoggingMiddleware</title><link>https://aleahim.com/LoggingMiddleware</link><description><![CDATA[In the world of OpenAPI-driven Swift servers, visibility is everything.You can‚Äôt fix what you can‚Äôt see ‚Äî and you can‚Äôt optimize what you don‚Äôt understand.]]></description><pubDate>Tue, 16 Sep 2025 00:00:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljevic]]></dc:creator><category><![CDATA[[Swift]]></category><category><![CDATA[OpenAPI]]></category><category><![CDATA[Vapor]]></category><category><![CDATA[Middleware]]></category><category><![CDATA[Logging]]></category><category><![CDATA[OpenSource]]></category><category><![CDATA[Architecture]]></category><category><![CDATA[ServerSideSwift]]]></category><content:encoded><![CDATA[<p>In the world of <strong>OpenAPI-driven Swift servers</strong>, visibility is everything.<br />You can‚Äôt fix what you can‚Äôt see ‚Äî and you can‚Äôt optimize what you don‚Äôt understand.</p><p>When I started building modular, OpenAPI-first architectures in Swift, one thing stood out: <strong>logging was either overwhelming or absent</strong>.<br />Either you got a raw dump of everything (headers, binary data, and stack traces), or you got nothing at all. Neither is particularly helpful when debugging or tracing an issue across microservices.</p><p>Frameworks like <strong>OpenAPIRuntime</strong> and <strong>OpenAPIVapor</strong> provide a strong foundation, but they deliberately avoid opinions about logging. They leave that up to you.<br />And that‚Äôs where most developers end up adding scattered <code>print()</code> statements or ad-hoc <code>logger.info()</code> calls inside handlers just to see what‚Äôs going on.</p><p>That‚Äôs not clean architecture. It‚Äôs noise.</p><p>So I built <strong>OpenAPILoggingMiddleware</strong>, a small, composable middleware that gives you <em>just enough visibility</em> ‚Äî not too much, not too little ‚Äî when working with OpenAPI-based servers.</p><hr /><h2>The Problem: Logging in a Generated World</h2><p>OpenAPI code generation has revolutionized how backend systems are written. You define your contracts, generate both server and client, and everything should ‚Äújust work.‚Äù<br />But once requests start flowing, visibility often becomes a blind spot.</p><p>If you‚Äôve ever tried debugging an OpenAPI-generated Swift server, you might recognize these problems:</p><ul><li>Middleware logs every byte of the body, even binary data.</li><li>Multi-part and SSE requests produce unreadable noise.</li><li>Response logs are buried under system output.</li><li>There‚Äôs no consistent way to see request duration or endpoint performance.</li><li>You can‚Äôt easily toggle verbosity levels or redact sensitive data.</li></ul><p>You end up either drowning in log output or adding <code>print</code> calls just to survive the debugging process.</p><p>This middleware solves that.</p><hr /><h2>The Solution: A Lightweight Logging Layer</h2><p><code>OpenAPILoggingMiddleware</code> sits quietly in the pipeline ‚Äî between your generated routes and the transport layer.<br />It listens to every incoming request and outgoing response, measures duration, and prints a <strong>structured summary</strong> of what happened.</p><p>At its core, the idea is simple:</p><blockquote><p>Log exactly what you‚Äôd want to see if you were reading someone else‚Äôs code.</p></blockquote><p>Here‚Äôs how it looks in your Vapor or OpenAPI setup:</p><pre><code class="language-swift">import OpenAPILoggingMiddleware

app.middleware.use(OpenAPILoggingMiddleware(level: .info))
</code></pre><p>That one line transforms your debugging experience.</p><hr /><h2>Under the Hood</h2><p>The middleware implements the <code>OpenAPIMiddleware</code> protocol, which lets it intercept the lifecycle of each OpenAPI operation ‚Äî before the request is handled and after the response is sent.</p><p>Here‚Äôs a conceptual overview:</p><pre><code class="language-swift">public struct OpenAPILoggingMiddleware: OpenAPIMiddleware {
    public func intercept(
        _ request: Request,
        operationID: String,
        next: (Request) async throws -> Response
    ) async throws -> Response {
        let start = Date()
        let response = try await next(request)
        let duration = Date().timeIntervalSince(start) * 1000

        print("[\(request.method)] \(request.url.path) -> \(response.status.code) [\(Int(duration)) ms]")
        return response
    }
}
</code></pre><p>Of course, the real implementation handles errors, structured formatting, and configurable verbosity, but the essence is the same:<br />it‚Äôs a <em>transparent layer of introspection</em> that doesn‚Äôt alter your data flow.</p><hr /><h2>Logging Philosophy</h2><p>There‚Äôs a fine balance between too much and too little information.</p><p>Traditional logging tools either <strong>dump everything</strong> (which nobody reads) or <strong>show too little</strong> (which leaves you guessing).<br /><code>OpenAPILoggingMiddleware</code> follows a <em>minimalist</em> principle inspired by Apple‚Äôs own frameworks ‚Äî log what matters, hide what doesn‚Äôt.</p><p>It‚Äôs designed around three key ideas:</p><ol><li><strong>Contextual logging</strong> ‚Äî every entry includes method, path, status, and duration.</li><li><strong>Progressive verbosity</strong> ‚Äî higher log levels show headers and bodies.</li><li><strong>Human readability first</strong> ‚Äî logs are meant to be scanned, not parsed by machines.</li></ol><p>Here‚Äôs an example of what a single request looks like in <code>.info</code> mode:</p><pre><code class="language-text">[POST] /mocks/messages/agent-responses (200 OK)
Duration: 123 ms
Body: {"message":"You shall not pass!"}
</code></pre><p>And at <code>.debug</code> level, you get more detail:</p><pre><code class="language-text">[POST] /mocks/messages/agent-responses
Headers:
  Content-Type: application/json
  Authorization: Bearer Gandalf-Was-Here-1
Duration: 123 ms
Body: {"message":"You shall not pass!"}
</code></pre><p>Readable. Structured. Useful.</p><hr /><h2>Why Not Just Use Vapor‚Äôs Logger?</h2><p>That‚Äôs a valid question.</p><p>Vapor already includes a powerful logging system based on SwiftLog, so why add another layer?<br />Because Vapor‚Äôs logger is <strong>request-agnostic</strong> ‚Äî it‚Äôs not aware of OpenAPI operations, generated endpoints, or typed models.</p><p><code>OpenAPILoggingMiddleware</code> is <strong>contract-aware</strong>.<br />It sits in the OpenAPI pipeline, so it can access the operation ID, typed body, and structured response ‚Äî all without touching your route handlers. That distinction is crucial for OpenAPI-based architectures, where most of your server logic is generated.</p><hr /><h2>Integration Examples</h2><p>Adding it to a Vapor-based OpenAPI server is trivial:</p><pre><code class="language-swift">import Vapor
import OpenAPIRuntime
import OpenAPIVapor
import OpenAPILoggingMiddleware

let app = try Application(.detect())

let server = try! MyOpenAPIServer(app: app)

app.middleware.use(OpenAPILoggingMiddleware(level: .info))
try app.run()
</code></pre><p>If you‚Äôre using <code>OpenAPIRuntime</code> directly (without Vapor), it‚Äôs equally simple:</p><pre><code class="language-swift">var server = try OpenAPIServer()
server.middleware.append(OpenAPILoggingMiddleware(level: .debug))
try server.start()
</code></pre><p>No configuration files. No dependencies. It just works.</p><hr /><h2>Extensibility and Customization</h2><p>Logging needs vary between environments.<br />In development, you might want to see every detail. In production, you want concise summaries. The middleware supports multiple log levels, allowing you to tailor verbosity to your needs:</p><ul><li><code>.error</code> ‚Äî log only failed requests.</li><li><code>.info</code> ‚Äî log all requests with method, path, duration, and status.</li><li><code>.debug</code> ‚Äî include headers and bodies.</li></ul><p>In future releases, I plan to add <strong>filters</strong> and <strong>formatters</strong> ‚Äî so you could, for instance, redact specific headers (<code>Authorization</code>, <code>Cookie</code>) or export logs in JSON format for ingestion into a centralized system.</p><p>Example:</p><pre><code class="language-swift">let middleware = OpenAPILoggingMiddleware(
    level: .debug,
    redactHeaders: ["Authorization", "Cookie"]
)
</code></pre><hr /><h2>Design Details: Why Simplicity Wins</h2><p>Many logging libraries start small and end up as frameworks. They introduce dependency graphs, adapters, output sinks, configuration DSLs ‚Äî and complexity sneaks in through the back door.</p><p>I deliberately avoided that path.</p><p><code>OpenAPILoggingMiddleware</code> does one thing: <strong>it shows what your OpenAPI server is doing</strong>.<br />Nothing else.</p><p>No JSON serialization frameworks. No dependency injection. No external configuration.<br />Just clean Swift and a single dependency on <code>OpenAPIRuntime</code>.</p><p>The codebase is small enough to read in one sitting ‚Äî and that‚Äôs intentional. In my opinion, <strong>you should be able to understand every line of code that runs in your server‚Äôs core path</strong>.</p><hr /><h2>Performance Considerations</h2><p>Logging always comes at a cost, but the impact here is minimal.<br />The middleware measures request duration using <code>Date().timeIntervalSince(start)</code>, which is negligible compared to network latency or I/O.</p><p>You can safely keep it enabled even in staging or pre-production environments.<br />In production, switching to <code>.error</code> mode will keep your logs clean while still providing visibility into failures.</p><hr /><h2>Testing and Debugging</h2><p>The middleware is fully testable using Vapor‚Äôs <code>Application</code> test harness or plain <code>XCTest</code> with mock requests.<br />Here‚Äôs a simple test that validates duration and structure:</p><pre><code class="language-swift">func testMiddlewareLogsRequestAndResponse() async throws {
    let app = Application(.testing)
    app.middleware.use(OpenAPILoggingMiddleware(level: .info))
    try await app.test(.POST, "/ping", afterResponse: { res in
        XCTAssertEqual(res.status, .ok)
    })
}
</code></pre><p>You can also inject your own logger conforming to <code>LogHandler</code> if you prefer structured output rather than printing to stdout.</p><hr /><h2>Future Work</h2><p>The roadmap includes:</p><ol><li><strong>JSON Formatter</strong> ‚Äî for structured logs in production environments.</li><li><strong>Redaction Rules</strong> ‚Äî for headers and sensitive body fields.</li><li><strong>Metrics Hooks</strong> ‚Äî integration with Swift Metrics or Prometheus.</li><li><strong>Pluggable Output Destinations</strong> ‚Äî allowing streaming to files or external monitoring systems.</li><li><strong>Async Logging</strong> ‚Äî offloading logging I/O to background tasks for ultra-high performance scenarios.</li></ol><p>Each of these will follow the same guiding principles: clarity, composability, and minimalism.</p><hr /><h2>Philosophy: Clean Visibility</h2><p>Logging is not just a developer tool ‚Äî it‚Äôs part of the interface between humans and systems.<br />A well-designed logging layer doesn‚Äôt scream for attention; it quietly reveals how the system behaves.</p><p>When I was designing this package, I thought about the elegance of Apple‚Äôs own frameworks ‚Äî the way their APIs feel inevitable, obvious in hindsight. That‚Äôs what I aim for here: <strong>a logging middleware that feels invisible until you need it, and indispensable once you use it.</strong></p><hr /><h2>Example Output in Context</h2><p>Here‚Äôs a real-world example of multiple concurrent requests hitting the same endpoint:</p><pre><code class="language-text">[GET] /user/profile (200 OK)
Duration: 87 ms

[POST] /mocks/messages/agent-responses (200 OK)
Duration: 121 ms
Body: {"message":"You shall not pass!"}

[PATCH] /user/preferences (204 No Content)
Duration: 96 ms
</code></pre><p>Notice how easy it is to see patterns ‚Äî which endpoints are slow, which ones are frequent, which ones failed.<br />That‚Äôs the essence of <strong>observability</strong> ‚Äî not more data, but <em>useful</em> data.</p><hr /><h2>Real-World Use</h2><p>I use <code>OpenAPILoggingMiddleware</code> in all my OpenAPI projects ‚Äî from small prototypes to complex SSE (Server-Sent Events) systems. It‚Äôs particularly valuable when debugging <strong>streamed responses</strong> or <strong>multipart form uploads</strong>, where conventional logs become unreadable.</p><p>Because it‚Äôs a simple <code>OpenAPIMiddleware</code>, it works with any generated server conforming to the OpenAPI ecosystem ‚Äî including custom transports and pure SwiftNIO backends.</p><hr /><h2>Closing Thoughts</h2><p>This middleware is a reminder that sometimes the simplest tools make the biggest difference.<br />It‚Äôs easy to underestimate the power of <strong>well-designed visibility</strong> ‚Äî until you remove it and start guessing again.</p><p>Whether you‚Äôre debugging mock routes, profiling API latency, or simply curious about what your server is doing, <code>OpenAPILoggingMiddleware</code> gives you that quiet transparency every developer deserves.</p><p>üëâ <strong>GitHub:</strong> <a href="https://github.com/mihaelamj/OpenAPILoggingMiddleware">mihaelamj/OpenAPILoggingMiddleware</a></p><hr /><p><em>‚ÄúClean code should be composable, testable, and visible when it runs.‚Äù</em></p>]]></content:encoded></item><item><guid isPermaLink="true">https://aleahim.com/ExtremePackaging</guid><title>ExtremePackaging</title><link>https://aleahim.com/ExtremePackaging</link><description><![CDATA[A Modular Architecture Methodology for Swift Projects By Mihaela Mihaljevic]]></description><pubDate>Sat, 13 Sep 2025 15:30:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljeevic]]></dc:creator><category><![CDATA[Swift]]></category><category><![CDATA[Package]]></category><category><![CDATA[extreme]]></category><category><![CDATA[Packaging]]></category><category><![CDATA[SPM]]></category><content:encoded><![CDATA[<p>A Modular Architecture Methodology for Swift Projects By Mihaela Mihaljevic</p><h2>Introduction</h2><p><strong>Extreme Packaging</strong> is a methodology for structuring Swift projects with <em>maximal modularity and minimal responsibility per module.</em> Each module represents a single, isolated unit of logic ‚Äî small enough to reason about, easy to test, and replaceable without side effects.</p><p>The core idea is <strong>separation</strong>: modules depend on stable interfaces, not on each other‚Äôs implementations. This enables scalable architectures that remain flexible as projects evolve, while keeping build times short and dependencies explicit.</p><p><strong>Table Of Contents:</strong></p><ul><li><a href="#part-1--project-setup">Part 1 ‚Äî Project Setup</a></li><li><a href="#part-2--tooling">Part 2 ‚Äî Tooling</a></li></ul><h3>Goals</h3><ul><li>Promote clean boundaries between domains and features</li><li>Enable independent development and testing per package</li><li>Simplify refactoring and dependency management</li><li>Keep compilation fast and the architecture transparent</li></ul><h3>Process</h3><p>The repository is organized into <strong>stages</strong>, each representing a self-contained checkpoint in the project‚Äôs evolution. When moving between stages ‚Äî especially when reverting to earlier ones ‚Äî always reset and clean your workspace to ensure it matches the intended state.</p><p>Here‚Äôs the example for <strong>stage 01</strong>:</p><pre><code class="language-bash"># Ensure you're on the branch you want
git checkout stage/01-init-packages

# Fetch the latest version
git fetch origin

# Reset your branch to the remote version
git reset --hard stage/01-init-packages

# Delete untracked files and directories
git clean -fdx
</code></pre><h3>Philosophy</h3><p>In most projects, modularization is an afterthought ‚Äî introduced when the codebase becomes too large to manage. <strong>Extreme Packaging</strong> inverts that approach: modularization is the starting point. By treating each package as an autonomous component from day one, you gain clarity, resilience, and a foundation that naturally scales with complexity.</p><h2>Part 1 ‚Äî Project Setup</h2><p>The first step in <strong>Extreme Packaging</strong> is establishing a clear and reproducible project structure that can evolve gradually through defined stages. Each stage in the repository builds upon the previous one ‚Äî from the initial package setup, to workspace creation, and finally to adding the app target that ties everything together.</p><h3>Overview</h3><p>The project begins as a <strong>Swift Package Manager‚Äìbased structure</strong>, designed for modularity from the start. At its core is a single <code>Packages</code> directory that houses all functional modules (such as <code>AppFeature</code>, <code>SharedModels</code>, and later others). Every addition to the project ‚Äî whether a new feature, UI layer, or platform target ‚Äî is layered on top of this foundation in small, trackable increments.</p><p>Here is the link to the project used: <a href="https://github.com/mihaelamj/ExtremePackaging/tree/stage/01-init-packages">https://github.com/mihaelamj/ExtremePackaging</a></p><h3>1.1 Stage 01 ‚Äî Initialize Packages</h3><h4>Purpose</h4><p>This stage ensures a working, self-contained Swift package that compiles and passes initial linting checks.</p><h4>Parts</h4><p>At <strong>stage/01-init-packages</strong>, the repository contains:</p><ul><li>A minimal <strong>package structure</strong> with <code>Sources</code> and <code>Tests</code></li><li><strong>Core configuration file</strong>s:<ul><li><code>.swiftlint.yml</code> for linting rules</li><li><code>.swiftformat</code> for consistent formatting</li><li><code>.gitignore</code>, <code>LICENSE</code>, and <code>README.md</code></li></ul></li><li><strong>Two base modules</strong>:<ul><li><code>AppFeature</code> ‚Äî serves as the entry feature for the app</li><li><code>SharedModels</code> ‚Äî holds simple model definitions</li></ul></li></ul><h4>Folder Structure snapshot</h4><p>Example folder structure: <img src="https://aleahim.com/images/xpack/Screenshot%25202025-03-31%2520at%252017.07.23.png" alt="" class="img-fluid"></p><p>Inside the  folder:</p><pre><code class="language-bash">
‚ûú  ExtremePackaging git:(main) ‚úó ls -all
 .
 ..
 .git
 .gitignore
 .swiftformat
 .swiftlint.yml
 Apps
 LICENSE
 Packages
 README.md
</code></pre><p>Inside the <code>Packages</code> folder:</p><pre><code class="language-bash">‚ûú  ExtremePackaging git:(main) cd Packages
‚ûú  Packages git:(main) ls -all
 .
 ..
 Package.swift
 Sources
 Tests
</code></pre><p>Inside the <code>Apps</code> folder:</p><pre><code class="language-bash">.
..
.gitkeep
</code></pre><h4>Basic Package Code:</h4><p>I start with package structure like this:</p><pre><code class="language-swift">// swift-tools-version: 6.0

import PackageDescription

let package = Package(
    name: "Main",
    platforms: [
        .iOS(.v17),
        .macOS(.v14),
    ],
    products: [
        .singleTargetLibrary("AppFeature"),
    ],
    dependencies: [
        .package(url: "https://github.com/realm/SwiftLint", exact: "0.52.3"),
    ],
    targets: [
        .target(
            name: "AppFeature",
            dependencies: [
                "SharedModels",
            ]
        ),
        .testTarget(
            name: "AppFeatureTests",
            dependencies: [
                "AppFeature"
            ]
        ),
        .target(
            name: "SharedModels"
        )
    ]
)

// Inject base plugins into each target
package.targets = package.targets.map { target in
    var plugins = target.plugins ?? []
    plugins.append(.plugin(name: "SwiftLintPlugin", package: "SwiftLint"))
    target.plugins = plugins
    return target
}

extension Product {
    static func singleTargetLibrary(_ name: String) -> Product {
        .library(name: name, targets: [name])
    }
}
</code></pre><h4>Dummy Files</h4><h5>AppView</h5><pre><code class="language-swift">import SharedModels
import SharedViews
import SwiftUI

public struct AppView: View {
    public var body: some View {
        VStack {
            Text("Extreme Packaging!")
                .font(.title)
                .fontWeight(.bold)
                .multilineTextAlignment(.center)
                .padding()
        }
    }
}
</code></pre><h5>DummyModel</h5><pre><code class="language-swift">import Foundation

public struct DummyModel: Identifiable {
    public var id: UUID = .init()
    public var title: String
    public init(
        id: UUID = .init(),
        title: String
    ) {
        self.id = id
        self.title = title
    }
}
</code></pre><h4>Stage 01-init-packages</h4><p>Here‚Äôs the code for <strong>stage 01</strong>:</p><pre><code class="language-bash">
# Clone repo if needed
git clone git@github.com:mihaelamj/ExtremePackaging.git

# Ensure you're on the branch you want
git checkout stage/01-init-packages

# Fetch the latest version
git fetch origin

# Reset your branch to the remote version
git reset --hard stage/01-init-packages

# Delete untracked files and directories
git clean -fdx
</code></pre><p>To see how it looks in <strong>Xcode</strong> we need to switch to subfolder <code>packages</code>, since we haven‚Äôt created the workspace yet.</p><pre><code class="language-bash">‚ûú  ExtremePackaging git:(stage/01-init-packages) ‚úó cd Packages
‚ûú  Packages git:(stage/01-init-packages) ‚úó xed .
</code></pre><h3>1.2 Stage 02 ‚Äî Add Workspace</h3><h4>Purpose</h4><p>In <strong>stage/02-workspace-added</strong>, an Xcode <strong>workspace</strong> named <code>Main.xcworkspace</code> is introduced at the project root. It includes the <code>Packages</code> folder, allowing smooth integration of multiple modules while keeping them decoupled. This step establishes the foundation for a multi-target environment.</p><h4>Workspace creation steps</h4><p>Create a new workspace (I name it <code>Main</code>), in the root of our folder.</p><p><img src="https://aleahim.com/images/xpack/workspace.png" alt="" class="img-fluid"></p><p>Add folder <code>Packages</code> to the workspace. It will add our package structure to the project:</p><p><img src="https://aleahim.com/images/xpack/Screenshot%25202025-03-31%2520at%252018.33.55.png" alt="" class="img-fluid"></p><h4>Stage 02-add‚Äîto-workspace</h4><p>Here‚Äôs the code for <strong>stage 02</strong>:</p><pre><code class="language-bash">
# Clone repo if needed
git clone git@github.com:mihaelamj/ExtremePackaging.git

# Ensure you're on the branch you want
git checkout stage/02-add‚Äîto-workspace

# Fetch the latest version
git fetch origin

# Reset your branch to the remote version
git reset --hard stage/02-add‚Äîto-workspace

# Delete untracked files and directories
git clean -fdx
</code></pre><p>Now we have the <strong>workspace</strong>, so we just need to open <strong>Xcode</strong>:</p><pre><code class="language-bash">‚ûú  Packages git:(stage/02-add‚Äîto-workspace) ‚úó xed .
‚ûú  Packages git:(stage/02-add‚Äîto-workspace) ‚úó
</code></pre><h3>1.3 Stage 03 ‚Äî Add iOS and macOS App Targets</h3><h4>Platform targets creation</h4><p><strong>Add new iOS and a new macOS project</strong> Repeat this for each target:</p><p>Create a new project in Xcode:</p><p><img src="https://aleahim.com/images/xpack/macos1.jpg" alt="" class="img-fluid"></p><p><img src="https://aleahim.com/images/xpack/macos2.jpg" alt="" class="img-fluid"></p><p>Add each to <code>Apps</code> folder:</p><p><img src="https://aleahim.com/images/xpack/macosFolder.jpg" alt="" class="img-fluid"></p><h4>Adding them to workspace</h4><p>We will be adding each app target to the workspace, below <em>Packages</em>. Open the current repository folder and drag both new projects (iOS and macOS) into the workspace sidebar.</p><p>Each target remains isolated within its own folder, but both share the same logic through the <em>AppFeature</em> module. This ensures that all common code ‚Äî views, models, and reducers ‚Äî stays within shared packages, while each platform target keeps its own configuration files.</p><p>Open the current repo folder: <img src="https://aleahim.com/images/xpack/show_in_finder.jpg" alt="" class="img-fluid"></p><p><img src="https://aleahim.com/images/xpack/folders_on_disk.jpg" alt="" class="img-fluid"></p><p>Add <strong>macOS</strong> target:</p><p><img src="https://aleahim.com/images/xpack/add_macos.jpg" alt="" class="img-fluid"></p><p>Choose ‚ÄúReference files in place‚Äù</p><p><img src="https://aleahim.com/images/xpack/reference_files.jpg" alt="" class="img-fluid"></p><p>This is how it looks when added:</p><p><img src="https://aleahim.com/images/xpack/add_macOS_done.jpg" alt="" class="img-fluid"></p><p>Add <strong>iOS</strong> target:</p><p><img src="https://aleahim.com/images/xpack/add_iOS.jpg" alt="" class="img-fluid"></p><p>This is how it looks when added:</p><p><img src="https://aleahim.com/images/xpack/add_iOS_done.jpg" alt="" class="img-fluid"></p><h4>Explanation: Why separate targets</h4><p>Keeping iOS and macOS projects distinct allows:</p><ul><li>Independent platform configuration (e.g. Info.plist, app icons, signing settings)</li><li>Platform-specific features when needed (e.g. menu commands on macOS, touch gestures on iOS)</li><li>Consistent architecture and shared logic through modular Swift packages</li></ul><p>This structure aligns perfectly with the <strong>Extreme Packaging</strong> philosophy ‚Äî shared foundation, platform-specific shells.</p><h4>Configuration steps</h4><ul><li>Delete automatically added <code>ContentView.swift</code></li><li>Add <code>AppFeature</code> package to the our target:</li></ul><p><img src="https://aleahim.com/images/xpack/AppTarget05.png" alt="" class="img-fluid"></p><p>Now our project looks like this: <img src="https://aleahim.com/images/xpack/AppTarget06.png" alt="" class="img-fluid"></p><p>And the main app starts with the fully testable <code>AppFeature</code></p><p><img src="https://aleahim.com/images/xpack/AppTarget07.png" alt="" class="img-fluid"></p><pre><code class="language-swift">import SwiftUI
import AppFeature

@main
struct SwiftUIAppApp: App {
    var body: some Scene {
        WindowGroup {
            AppView()
        }
    }
}
</code></pre><h4>Final structure</h4><p>At this point, the project has evolved into a fully cross-platform modular setup.</p><p>The screenshot below illustrates the final structure after completing <strong>Stage 03 (iOS & macOS targets added)</strong>:</p><p><img src="https://aleahim.com/images/xpack/final_struc.jpg" alt="" class="img-fluid"></p><ul><li>The <strong>Packages</strong> directory defines the shared Swift Package with <code>AppFeature</code> and <code>SharedModels</code> modules.</li><li>Both <strong>iOS</strong> and <strong>macOS</strong> apps live inside the <code>Apps</code> folder, each with its own assets, entry point, and platform-specific configuration files.</li><li>The <strong><code>Package.swift</code></strong> file defines a single modular product, with SwiftLint integrated as a plugin and dependencies kept cleanly separated.</li><li>This structure enables both platforms to share logic and UI built with <strong>SwiftUI</strong>, while still allowing native customization per platform.</li></ul><p><strong>Result:</strong> A clean, modular workspace where shared code resides in packages, and each platform acts only as a thin presentation shell ‚Äî the essence of <em>Extreme Packaging</em>.</p><h4>Stage 03-apps-added</h4><p>In <strong>stage/03-apps-added</strong>, we create two separate app targets ‚Äî one for <strong>iOS</strong> and one for <strong>macOS</strong> ‚Äî both sharing the same SwiftUI core logic.</p><p>Each app lives inside the <code>Apps</code> folder and imports the <code>AppFeature</code> module, demonstrating how the same feature package can power multiple platforms with no duplicated code.</p><p>After adding the targets:</p><ul><li>Delete the automatically generated <code>ContentView.swift</code></li><li>Add the <code>AppFeature</code> package dependency to both targets</li><li>Verify that both apps build successfully</li></ul><p>This stage concludes with a fully functional cross-platform setup where both iOS and macOS share a unified architecture driven by modular packages.</p><p>Here‚Äôs the code for <strong>stage 03</strong>:</p><pre><code class="language-bash">
# Clone repo if needed
git clone git@github.com:mihaelamj/ExtremePackaging.git

# Ensure you're on the branch you want
git checkout stage/03-apps-added

# Fetch the latest version
git fetch origin

# Reset your branch to the remote version
git reset --hard stage/03-apps-added

# Delete untracked files and directories
git clean -fdx
</code></pre><h3>Summary</h3><table class="table"><thead><th scope="col">Stage</th><th scope="col">Description</th><th scope="col">Key Additions</th></thead><tbody><tr><td><strong>01</strong></td><td>Initial package setup</td><td><code>Package.swift</code>, SwiftLint & SwiftFormat configs, dummy modules (<code>AppFeature</code>, <code>SharedModels</code>)</td></tr><tr><td><strong>02</strong></td><td>Workspace creation</td><td><code>Main.xcworkspace</code>, integrated <code>Packages</code> folder for modular management</td></tr><tr><td><strong>03</strong></td><td>iOS & macOS app targets added</td><td>Separate iOS and macOS apps in <code>Apps/</code>, both using <code>AppFeature</code> for shared SwiftUI logic</td></tr></tbody></table><p>Each stage corresponds to a dedicated branch in the repository, allowing you to switch between checkpoints and observe the project‚Äôs evolution step by step. This structure provides a transparent history of how a modular Swift project grows from a single package into a fully multi-platform architecture.</p><h2>Part 2 ‚Äî Tooling</h2><ul><li>Every project includes <strong>SwiftLint</strong> and <strong>SwiftFormat</strong> for enforcing consistent code style and quality</li><li>Each stage of the repository introduces incremental improvements, from initializing packages to adding app targets and integrations</li><li>These are applied from the very first stage but can be customized at any point.</li></ul><h3>GitIgnore</h3><pre><code class="language-bash"># Xcode
#
# gitignore contributors: remember to update Global/Xcode.gitignore, Objective-C.gitignore & Swift.gitignore

## User settings
xcuserdata/

## Obj-C/Swift specific
*.hmap

## App packaging
*.ipa
*.dSYM.zip
*.dSYM

## Playgrounds
timeline.xctimeline
playground.xcworkspace

# Swift Package Manager
.build/
.swiftpm/
Package.resolved

# Xcode workspace & projects
*.xcworkspace/xcshareddata/WorkspaceSettings.xcsettings
*.xcworkspace/xcuserdata/
DerivedData/
*.xcuserstate
*.xcscmblueprint
*.xccheckout

# macOS system files
.DS_Store

# Carthage
Carthage/Build/

# fastlane
fastlane/report.xml
fastlane/Preview.html
fastlane/screenshots/**/*.png
fastlane/test_output

# Custom folders used in ExtremePackaging
Stage/
Tasks/.build/
</code></pre><h3>SwiftFormat Config</h3><p>This is my <code>.swiftformat</code></p><pre><code class="language-yaml"># General Options
--swiftversion 5.7

# File Options
--exclude Stage,Tasks/.build,ThirdParty,**/SwiftGen/*,**/Sourcery/*,Frameworks/swift-composable-architecture,**.generated.swift

# Format Options

--allman false
--binarygrouping none
--closingparen balanced
--commas always
--conflictmarkers reject
--decimalgrouping none
--elseposition same-line
--exponentcase lowercase
--exponentgrouping disabled
--fractiongrouping disabled
--fragment false
--header ignore
--hexgrouping none
--hexliteralcase lowercase
--ifdef no-indent
--importgrouping alphabetized
--indent 4
--indentcase false
# make sure this matches .swiftlint
--maxwidth 180
--nospaceoperators ..<,...
--octalgrouping none
--operatorfunc no-space
--selfrequired
--stripunusedargs closure-only
--trailingclosures
--wraparguments before-first
--wrapcollections before-first
--wrapparameters before-first

# Rules
--disable hoistAwait
--disable hoistPatternLet
--disable hoistTry
--disable wrapMultilineStatementBraces
--disable extensionAccessControl
</code></pre><h3>SwiftLint Config</h3><pre><code class="language-yaml">disabled_rules: # rule identifiers to exclude from running
  - opening_brace
  - operator_whitespace
  - orphaned_doc_comment

opt_in_rules:
  - empty_count
  - force_unwrapping
  - shorthand_optional_binding
  - weak_delegate

excluded:
  - "*.generated"

custom_rules:
  # check's for Combine's .assign(to: xxx, on: self) ref-cycle
  combine_assign_to_self:
    included: ".*\\.swift"
    name: "`assign` to self"
    regex: '\.assign\(to: [^,]*, on: self\)'
    message: "For assigning on self, use assignNoRetain(to: ..., on: self)."
    severity: error
  duplicate_remove_duplicates:
    included: ".*\\.swift"
    name: "Duplicate `removeDuplicates()`"
    message: "ViewStore's publisher already does `removeDuplicates()`"
    regex: 'publisher\.[^(|{|,]*removeDuplicates\(\)'
    severity: error
  dont_scale_to_zero:
    included: ".*\\.swift"
    name: "Don't scale down to 0."
    regex: "\\.scaleEffect\\([^\\)]*(\\ 0\\ [^\\)]*\\)|0.0(\\ |\\))|\\ 0(\\)|,))"
    message: "Please make sure to pass a number not equal zero, so transformations don't throw warnings like `ignoring singular matrix`."
    severity: error
  use_data_constructor_over_string_member:
    included: ".*\\.swift"
    name: "Do not use String.data(using: .utf8)"
    regex: "\\.?data\\(using: \\.utf8\\)"
    message: "Please use Data(string.utf8) instead of String.data(using: .utf8) because the Data constructor is non-optional and Strings are guaranteed to be encodable as .utf8"
    severity: error
  tca_explicit_generics_reducer:
    included: ".*\\.swift"
    name: "Explicit Generics for Reducer"
    regex: 'Reduce\s+\{'
    message: "Use explicit generics in ReducerBuilder (Reduce<State, Action>) for successful autocompletion."
    severity: error
  tca_scope_unused_closure_parameter:
    name: "TCA Scope Unused Closure Parameter"
    regex: '\.scope\(\s*state\s*:\s*\{\s*\_'
    message: "Explicitly use closure parameter when scoping store (ensures the right state is being mutated)"
    severity: error
  tca_use_observe_viewstore_api:
    name: "TCA ViewStore observe API"
    regex: 'ViewStore\(store\.scope'
    message: "Use modern observe: api instead of store.scope"
    severity: error

trailing_comma:
    mandatory_comma: true

cyclomatic_complexity:
  ignores_case_statements: true
  warning: 20

file_length:
  warning: 1000
  error: 1000

identifier_name:
  severity: warning
  allowed_symbols: "_"
  min_length: 2
  max_length:
    warning: 90
    error: 90
  excluded:
    - iO
    - id
    - vc
    - x
    - y
    - i
    - pi
    - d

legacy_constant: error
legacy_constructor: error

line_length:
  warning: 180
  error: 180
  ignores_comments: true
  ignores_urls: true

nesting:
  type_level:
    warning: 3
    error: 3
  function_level:
    warning: 5
    error: 5

function_parameter_count:
  warning: 5

force_cast: warning
force_unwrapping: warning

type_body_length:
  - 300 # warning
  - 300 # error

large_tuple:
  - 3  # warning
  - 10 # error%
</code></pre>]]></content:encoded></item><item><guid isPermaLink="true">https://aleahim.com/CVBuilder</guid><title>CVBuilder: A Swift Package for Professional CV Management</title><link>https://aleahim.com/CVBuilder</link><description><![CDATA[CVBuilder is a powerful Swift package that I developed to solve a common problem: managing and rendering professional CVs in multiple formats. Whether you need to generate a Markdown CV for GitHub, an HTML version for your website, or a plain text version for job applications, CVBuilder has you covered.]]></description><pubDate>Sat, 13 Apr 2024 15:30:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljeevic]]></dc:creator><category><![CDATA[Swift]]></category><category><![CDATA[Package]]></category><category><![CDATA[CV]]></category><category><![CDATA[Markdown]]></category><category><![CDATA[HTML]]></category><category><![CDATA[SPM]]></category><content:encoded><![CDATA[<p>CVBuilder is a powerful Swift package that I developed to solve a common problem: managing and rendering professional CVs in multiple formats. Whether you need to generate a Markdown CV for GitHub, an HTML version for your website, or a plain text version for job applications, CVBuilder has you covered.</p><h2>Why CVBuilder?</h2><p>In today‚Äôs digital world, professionals often need to maintain their CVs in multiple formats and keep them in sync. Traditional word processors make this process tedious and error-prone. CVBuilder solves this by:</p><ul><li>Providing a strongly-typed data model for CVs</li><li>Supporting multiple output formats (Markdown, HTML, plain text)</li><li>Making it easy to maintain a single source of truth</li><li>Enabling programmatic CV generation and updates</li></ul><h2>Core Features</h2><h3>1. Strongly Typed Data Model</h3><p>CVBuilder provides a comprehensive data model that covers all aspects of a professional CV:</p><pre><code class="language-swift">CV
‚îú‚îÄ‚îÄ ContactInfo
‚îú‚îÄ‚îÄ Education
‚îú‚îÄ‚îÄ WorkExperience
‚îÇ   ‚îú‚îÄ‚îÄ Company
‚îÇ   ‚îú‚îÄ‚îÄ Role
‚îÇ   ‚îî‚îÄ‚îÄ ProjectExperience
‚îÇ       ‚îú‚îÄ‚îÄ Project
‚îÇ       ‚îî‚îÄ‚îÄ Tech
‚îî‚îÄ‚îÄ Period
</code></pre><p>Each component is strongly typed, ensuring data integrity and making it impossible to create invalid CVs.</p><h3>2. Multiple Renderers</h3><p>CVBuilder supports three different renderers out of the box:</p><ol><li><strong>MarkdownCVRenderer</strong>: Generates clean, well-formatted Markdown</li><li><strong>StringCVRenderer</strong>: Produces plain text output</li><li><strong>IgniteRenderer</strong>: Creates beautiful HTML using the Ignite static site generator</li></ol><h3>3. Modular Architecture</h3><p>The package is split into two main components:</p><ul><li><code>CVBuilder</code>: Core types and basic rendering</li><li><code>CVBuilderIgnite</code>: Optional HTML rendering support</li></ul><p>This separation ensures that projects that don‚Äôt need HTML rendering don‚Äôt have to pull in unnecessary dependencies.</p><h2>Getting Started</h2><h3>Installation</h3><p>Add CVBuilder to your project using Swift Package Manager:</p><pre><code class="language-swift">.package(url: "https://github.com/mihaelamj/cvbuilder.git", branch: "main")
</code></pre><p>Then add the desired product:</p><pre><code class="language-swift">.product(name: "CVBuilder", package: "cvbuilder"),
.product(name: "CVBuilderIgnite", package: "cvbuilder") // if using Ignite
</code></pre><h3>Creating a CV</h3><p>Here‚Äôs a simple example of creating a CV:</p><pre><code class="language-swift">import CVBuilder

// Create contact info
let contactInfo = ContactInfo(
    email: "jane.doe@example.com",
    phone: "+1 (555) 123-4567",
    linkedIn: URL(string: "https://linkedin.com/in/janedoe"),
    github: URL(string: "https://github.com/janedoe"),
    website: URL(string: "https://janedoe.dev"),
    location: "San Francisco, CA"
)

// Create education
let education = Education(
    institution: "Stanford University",
    degree: "B.S.",
    field: "Computer Science",
    period: Period(
        start: .init(month: 9, year: 2010),
        end: .init(month: 6, year: 2014)
    )
)

// Create the CV
let cv = CV.create(
    name: "Jane Doe",
    title: "Senior Mobile Developer",
    summary: "Passionate mobile developer with 5+ years experience...",
    contactInfo: contactInfo,
    education: [education],
    projects: [project1, project2]
)
</code></pre><h3>Generating Output</h3><p>Once you have your CV data model, generating different formats is straightforward:</p><pre><code class="language-swift">// Generate Markdown
let markdown = MarkdownCVRenderer(cv: cv).render()

// Generate plain text
let plainText = StringCVRenderer(cv: cv).render()

// Generate HTML (requires CVBuilderIgnite)
let html = IgniteRenderer(cv: cv).render()
</code></pre><h2>Advanced Features</h2><h3>Project Builder Pattern</h3><p>CVBuilder includes a builder pattern for creating project experiences:</p><pre><code class="language-swift">let project = try! Project.Builder()
    .withName("iOS App Redesign")
    .withCompany(appleCompany)
    .withRole(seniorIOS)
    .withPeriod(start: (month: 3, year: 2020), end: (month: 9, year: 2021))
    .addDescription("Led a team of 5 developers...")
    .withTechs([swift, swiftUI])
    .build()
</code></pre><h3>Tech Stack Management</h3><p>The package includes a <code>Tech</code> type for managing technical skills:</p><pre><code class="language-swift">let swift = Tech(name: "Swift", category: .language)
let swiftUI = Tech(name: "SwiftUI", category: .framework)
let restAPI = Tech(name: "REST API", category: .concept)
</code></pre><h2>How I Use It on This Webpage</h2><p>My blog is built using <a href="https://github.com/twostraws/Ignite">Ignite</a>, a static site generator for Swift. I‚Äôve integrated CVBuilder into my website to maintain and display my CV in a clean, professional format.</p><h3>Package Dependencies</h3><p>I include CVBuilder in my website‚Äôs package file:</p><pre><code class="language-swift">let package = Package(
    name: "IgniteStarter",
    platforms: [.macOS(.v13)],
    dependencies: [
        .package(url: "https://github.com/twostraws/Ignite.git", branch: "main"),
        .package(url: "https://github.com/mihaelamj/cvbuilder.git", branch: "main")
    ],
    targets: [
        .executableTarget(
            name: "IgniteStarter",
            dependencies: [
                .product(name: "Ignite", package: "Ignite"),
                .product(name: "CVBuilder", package: "cvbuilder"),
                .product(name: "CVBuilderIgnite", package: "cvbuilder")
            ]
        ),
    ]
)
</code></pre><h3>Personal Information</h3><p>I maintain my personal information in a dedicated Swift file (<code>CV+Mihaela.swift</code>):</p><pre><code class="language-swift">public extension CV {
    static func createForMihaela() -> CV {
        let contactInfo = ContactInfo(
            email: "me@me.com",
            phone: "+12233445566",
            linkedIn: URL(string: "https://www.linkedin.com/in/mylinkedin"),
            github: URL(string: "https://github.com/mygithub"),
            website: URL(string: "https://mywebsite.com"),
            location: "City, Country"
        )
        
        let education = Education(...)
        
        // ... rest of the implementation
    }
}
</code></pre><p><img src="https://aleahim.com/images/cvbuilder/cv01.png" alt="" class="img-fluid"></p><h3>Project History</h3><p>My professional experience is organized in a separate file (<code>CV+Projects.swift</code>), which contains detailed information about all my projects:</p><pre><code class="language-swift">public extension CV {
    static func createMihaelasProjects() -> [Project] {
        var result = [Project]()
        
        // Create companies
        let undabot = Company(name: "Undabot")
        let token = Company(name: "Token")
        // ... more companies
        
        // Create tech skills
        let swift = Tech(name: "Swift", category: .language)
        let uiKit = Tech(name: "UIKit", category: .framework)
        // ... more tech skills
        
        // Create projects using the builder pattern
        let project1 = try! Project.Builder()
            .withName("SomeProject")
            .withCompany(Company name)
            .withRole(juniorIOS)
            .withPeriod(start: (month: 9, year: 20XX), end: (month: 12, year: 20XX))
            .addDescription("iOS (iPad) book application about...)
            .withTechs([swift, uiKit])
            .build()
        
        // ... more projects
        
        return result
    }
}
</code></pre><p>This modular approach allows me to:</p><ol><li>Keep my CV data in a strongly-typed format</li><li>Easily update my experience and skills</li><li>Generate both HTML and Markdown versions of my CV</li><li>Maintain consistency across different platforms</li></ol><p>The CV is automatically generated when the website is built, ensuring that my professional information is always up-to-date and consistently formatted.</p><h3>Markdown Generation</h3><p>I also generate a Markdown version of my CV that I can use to create a fresh PDF whenever needed. This is done using a simple function:</p><pre><code class="language-swift">func generateMihaelasCVMarkdownInContentFolder() {
    let cv = CV.createForMihaela()
    let markdown = MarkdownCVRenderer().render(cv: cv)

    let fileURL = URL(fileURLWithPath: "Assets/mihaela-cv.md")

    do {
        try markdown.write(to: fileURL, atomically: true, encoding: .utf8)
        print("‚úÖ Written to \(fileURL.path)")
    } catch {
        print("‚ùå Failed to write Mihaela's CV: \(error.localizedDescription)")
    }
}
</code></pre><p>This function:</p><ol><li>Creates my CV using the <code>createForMihaela()</code> function</li><li>Renders it to Markdown using <code>MarkdownCVRenderer</code></li><li>Saves the output to <code>Assets/mihaela-cv.md</code></li><li>Provides feedback about the success or failure of the operation</li></ol><p>I can then use this Markdown file to generate a fresh PDF whenever I need to update my CV for job applications or other purposes.</p><h2>Future Plans</h2><p>CVBuilder is actively maintained and has several planned improvements:</p><ol><li>Command-line interface for CV generation</li><li>Additional renderers (PDF, LaTeX)</li><li>Import/export functionality for common formats</li><li>Template system for customizing output</li></ol><h2>Conclusion</h2><p>CVBuilder provides a robust solution for managing professional CVs in Swift. Its type-safe design, multiple renderers, and modular architecture make it an excellent choice for developers who want to maintain their CVs programmatically.</p><p>Whether you‚Äôre building a personal website, managing multiple CV versions, or creating a CV management system, CVBuilder can help streamline your workflow and ensure consistency across all your professional documents.</p><h2>Resources</h2><ul><li><a href="https://github.com/mihaelamj/cvbuilder">GitHub Repository</a></li><li><a href="https://github.com/mihaelamj/cvbuilder/blob/main/SampleCV.md">Sample CV</a></li><li><a href="https://github.com/mihaelamj/cvbuilder#readme">Documentation</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://aleahim.com/SwiftUILabAdvancedAnimations</guid><title>Bringing Advanced SwiftUI Animations to macOS</title><link>https://aleahim.com/SwiftUILabAdvancedAnimations</link><description><![CDATA[When I first discovered SwiftUILab‚Äôs Advanced Animations, I was impressed by the beautiful animations and transitions it demonstrated. However, I noticed that these examples were primarily focused on iOS, leaving macOS developers without a clear path to implement similar effects. This inspired me to create SwiftUILab_AdvancedAnimations, a port of these animations that works seamlessly on both iOS and macOS.]]></description><pubDate>Sun, 13 Feb 2022 16:30:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljeevic]]></dc:creator><category><![CDATA[Swift]]></category><category><![CDATA[SwiftUI]]></category><category><![CDATA[Animation]]></category><category><![CDATA[macOS]]></category><category><![CDATA[iOS]]></category><content:encoded><![CDATA[<p>When I first discovered <a href="https://swiftui-lab.com/advanced-animations/">SwiftUILab‚Äôs Advanced Animations</a>, I was impressed by the beautiful animations and transitions it demonstrated. However, I noticed that these examples were primarily focused on iOS, leaving macOS developers without a clear path to implement similar effects. This inspired me to create <a href="https://github.com/mihaelamj/SwiftUILab_AdvancedAnimations">SwiftUILab_AdvancedAnimations</a>, a port of these animations that works seamlessly on both iOS and macOS.</p><h2>The Challenge</h2><p>SwiftUI‚Äôs animation system is powerful but can behave differently across platforms. While iOS and macOS share the same SwiftUI framework, there are subtle differences in how animations are handled, especially when dealing with:</p><ul><li>Gesture recognizers</li><li>View transitions</li><li>Animation timing</li><li>Platform-specific UI elements</li></ul><p>My goal was to create a unified codebase that would work flawlessly on both platforms while maintaining the original animations‚Äô elegance and performance.</p><h2>Project Structure</h2><p>I organized the project to make it easy to understand and extend:</p><pre><code>SwiftUILab_AA/
‚îú‚îÄ‚îÄ Examples/
‚îÇ   ‚îú‚îÄ‚îÄ Animation1/
‚îÇ   ‚îú‚îÄ‚îÄ Animation2/
‚îÇ   ‚îî‚îÄ‚îÄ ...
‚îú‚îÄ‚îÄ Shared/
‚îÇ   ‚îú‚îÄ‚îÄ Views/
‚îÇ   ‚îú‚îÄ‚îÄ Models/
‚îÇ   ‚îî‚îÄ‚îÄ Extensions/
‚îî‚îÄ‚îÄ App/
    ‚îú‚îÄ‚îÄ iOS/
    ‚îî‚îÄ‚îÄ macOS/
</code></pre><p>Each animation example has its own folder, making it easy to:</p><ul><li>Study individual animations in isolation</li><li>Copy and paste specific animations into other projects</li><li>Modify and experiment with different parameters</li></ul><h2>Key Features</h2><h3>1. Cross-Platform Compatibility</h3><p>The project uses SwiftUI‚Äôs platform-agnostic features while handling platform-specific requirements:</p><pre><code class="language-swift">#if os(iOS)
    // iOS-specific code
#elseif os(macOS)
    // macOS-specific code
#endif
</code></pre><h3>2. Reusable Components</h3><p>I created a set of reusable components that work on both platforms:</p><pre><code class="language-swift">struct AnimatedButton: View {
    @State private var isPressed = false
    
    var body: some View {
        Button(action: {}) {
            Text("Animate")
                .scaleEffect(isPressed ? 0.95 : 1.0)
                .animation(.spring(), value: isPressed)
        }
        .buttonStyle(PlainButtonStyle())
        .onHover { hovering in
            isPressed = hovering
        }
    }
}
</code></pre><h3>3. Gesture Handling</h3><p>The project includes platform-appropriate gesture handling:</p><pre><code class="language-swift">struct DragGestureView: View {
    @State private var offset = CGSize.zero
    
    var body: some View {
        Rectangle()
            .fill(Color.blue)
            .frame(width: 100, height: 100)
            .offset(offset)
            .gesture(
                DragGesture()
                    .onChanged { value in
                        offset = value.translation
                    }
                    .onEnded { _ in
                        withAnimation(.spring()) {
                            offset = .zero
                        }
                    }
            )
    }
}
</code></pre><h2>Example Animations</h2><h3>1. Morphing Shapes</h3><p>One of the most impressive animations is the shape morphing effect:</p><pre><code class="language-swift">struct MorphingShape: View {
    @State private var isMorphed = false
    
    var body: some View {
        Circle()
            .fill(Color.blue)
            .frame(width: 100, height: 100)
            .scaleEffect(isMorphed ? 1.5 : 1.0)
            .animation(.spring(response: 0.6, dampingFraction: 0.6), value: isMorphed)
            .onTapGesture {
                isMorphed.toggle()
            }
    }
}
</code></pre><h3>2. Custom Transitions</h3><p>The project includes several custom transitions that work on both platforms:</p><pre><code class="language-swift">extension AnyTransition {
    static var customScale: AnyTransition {
        .scale(scale: 0.1)
        .combined(with: .opacity)
    }
}
</code></pre><h2>Implementation Details</h2><h3>1. View Extensions</h3><p>I created several extensions to make animations more reusable:</p><pre><code class="language-swift">extension View {
    func animateOnHover() -> some View {
        self.modifier(HoverAnimationModifier())
    }
}
</code></pre><h3>2. Animation Timing</h3><p>Careful attention was paid to animation timing to ensure smooth performance:</p><pre><code class="language-swift">struct TimingAnimation: View {
    @State private var isAnimating = false
    
    var body: some View {
        Circle()
            .fill(Color.red)
            .frame(width: 50, height: 50)
            .offset(y: isAnimating ? -100 : 0)
            .animation(
                .timingCurve(0.68, -0.6, 0.32, 1.6, duration: 1),
                value: isAnimating
            )
            .onAppear {
                isAnimating = true
            }
    }
}
</code></pre><h2>Benefits for Developers</h2><ol><li><strong>Cross-Platform Learning</strong>: Developers can learn SwiftUI animations that work on both iOS and macOS</li><li><strong>Ready-to-Use Examples</strong>: Each animation is self-contained and can be easily copied into other projects</li><li><strong>Performance Optimized</strong>: Animations are optimized for smooth performance on both platforms</li><li><strong>Educational Resource</strong>: The project serves as a comprehensive guide to SwiftUI animations</li></ol><h2>Future Improvements</h2><p>The project is actively maintained with several planned enhancements:</p><ol><li>Adding more complex animation examples</li><li>Implementing accessibility features</li><li>Creating a documentation site with interactive examples</li><li>Adding support for visionOS</li></ol><h2>Conclusion</h2><p>SwiftUILab_AdvancedAnimations bridges the gap between iOS and macOS animation development in SwiftUI. By providing a unified codebase and clear examples, it helps developers create beautiful, performant animations that work across Apple‚Äôs platforms.</p><p>Whether you‚Äôre building for iOS, macOS, or both, this project provides valuable insights into SwiftUI‚Äôs animation capabilities and best practices for cross-platform development.</p><h2>Resources</h2><ul><li><a href="https://github.com/mihaelamj/SwiftUILab_AdvancedAnimations">GitHub Repository</a></li><li><a href="https://swiftui-lab.com/advanced-animations/">Original SwiftUILab Article</a></li><li><a href="https://developer.apple.com/documentation/swiftui">SwiftUI Documentation</a></li></ul>]]></content:encoded></item><item><guid isPermaLink="true">https://aleahim.com/CoreAnimation3DCube</guid><title>Core Animation Layers forming a 3D cube</title><link>https://aleahim.com/CoreAnimation3DCube</link><description><![CDATA[]]></description><pubDate>Sat, 06 Mar 2021 15:30:00 +0000</pubDate><dc:creator><![CDATA[Mihaela Mihaljeevic]]></dc:creator><category><![CDATA[Core Animation]]></category><category><![CDATA[Swift]]></category><category><![CDATA[Objective-C]]></category><category><![CDATA[UIKit]]></category><category><![CDATA[AppKit]]></category><content:encoded><![CDATA[<p><img src="https://aleahim.com/images/cacube/01_cube_iOS_3D.png" alt="" class="img-fluid"></p><p>I‚Äôve been researching <code>Core Animation</code> framework for the past few months.<br />I‚Äôve started with several books on the subject, but I found watching related WWDC videos most rewarding. The presenters put the content in a relevant context which  makes it easier to apprehend and learn from it.</p><h2>1. Introduction</h2><p>One WWDC session particularly intrigued me: ‚Äú2011‚Äì421 Core Animation Essentials‚Äù. They presented their demo named: ‚ÄúLayers in Perspective‚Äù, and it showed six layers, forming a flattened cube: <img src="https://aleahim.com/images/cacube/02_cube_5sides.png" alt="" class="img-fluid"></p><p>The sixth layer is hiding behind the layer number 5. It has a lower <code>zPosition</code> then the layer above it.</p><p><img src="https://aleahim.com/images/cacube/03_cube_6sides.png" alt="" class="img-fluid"></p><p>They have also demonstrated opening and closing the cube formation.</p><p><img src="https://aleahim.com/images/cacube/04_cube_filmstrip.png" alt="" class="img-fluid"></p><p>So, I have decided to demonstrate that.</p><p>Here‚Äôs a link to a GitHub repo with the source code:<br /><a href="https://github.com/mihaelamj/CubeIn3DWithCoreAnimation">Core Animation 3D Cube</a></p><p>Here‚Äôs the animation:</p><p><img src="https://aleahim.com/images/cacube/05_CoreAnimation_3D_Cube.gif" alt="" class="img-fluid"></p><p>You can also see it on <a href="https://www.youtube.com/watch?v=exIGbi36_bk">You Tube</a></p><p>Layers in <code>Core Animation</code> live in <code>3D</code> geometry. But a layer is a <code>2D</code> construct, so <code>Core Animation</code> coordinate space is called a <code>2.5D</code> geometry.</p><p>To illustrate that just see what happens when you mess up your transformations.</p><p><img src="https://aleahim.com/images/cacube/06_Intersecting_Layers.png" alt="" class="img-fluid"></p><p>Layers are <code>2D</code> objects, they don‚Äôt understand the third dimension.<br />They are like playing cards in space., and there is no <code>depth buffer</code> available.</p><p>And also, intersecting layers should be avoided because in the image above, Core Animation needs to do a lot of work. So just to draw the <code>red</code> layer intersecting only the <code>blue</code> layer, Core Animation needs to</p><ul><li>cut the <code>red</code> layer into two pieces</li><li>render back part of the <code>red</code> layer</li><li>then render the full <code>blue</code> layer</li><li>then render the front part of the <code>red</code> layer again And all that work is for just intersection, and here we have multiple.</li></ul><h2>2. Building the Cube in 3D</h2><h3>2.1. Setting up the multi-platform project</h3><p>I wanted the project to fun on the <code>macOS</code> , <code>iOS</code> and <code>iPadOS</code>, so I used <a href="https://github.com/mihaelamj/allapples">AllApples</a> Swift package.</p><p>After removing the storyboards and pimping up the <code>AppDelegate</code> and <code>main.swift</code> for the <code>macOS</code> version, and <code>SceneDelegate</code> for the mobile versions, I was ready to start.</p><h4>2.1.1. <code>main.swift</code> for the macOS</h4><pre><code class="language-swift">import Cocoa
let delegate = AppDelegate()
NSApplication.shared.delegate = delegate
_ = NSApplicationMain(CommandLine.argc, CommandLine.unsafeArgv)
</code></pre><h4>2.1.2. AppDelegate for the <code>macOS</code></h4><pre><code class="language-swift">import Cocoa
import AllApples

class AppDelegate: NSObject, NSApplicationDelegate {
  private var window: NSWindow?
  func applicationDidFinishLaunching(_ aNotification: Notification) {
    window = AppSceneDelegate.makeWindow_Mac(theVC: CommonViewController())
  }
}
</code></pre><h4>2.1.3. SceneDelegate for the <code>iOS</code> and <code>iPadOS</code></h4><pre><code class="language-swift">import UIKit
import AllApples

class SceneDelegate: UIResponder, UIWindowSceneDelegate {
  var window: UIWindow?
  func scene(_ scene: UIScene, willConnectTo session: UISceneSession, options connectionOptions: UIScene.ConnectionOptions) {
    guard let aScene = (scene as? UIWindowScene) else { return }
    window = AppSceneDelegate.makeWindow_iOS(theScene: aScene, theVC: CommonViewController())
  }
}
</code></pre><h3>2.2. Building the Basic Blocks</h3><p>The first I did is make a <code>PlainLayerView¬†</code>. It is an <code>AView</code> descendant, which means that it is <code>typedef-ed</code> to be either a <code>UIView</code> or a <code>NSView</code>.</p><p>It is an intermediary object just to set up a thing on the <code>macOS</code> as well (doesn‚Äôt work yet).</p><p>I then created <code>CustomLayerView</code> to have nice sides for the cube, with <code>CATextLayer</code> as the number of the cube side, and a nice rounded border, so that we can peek into our cube while rotating.</p><p>Here‚Äôs the image of all six layers drawn by using a <code>CustomLayerView</code></p><p><img src="https://aleahim.com/images/cacube/07_original_abandoned_cube_layout.png" alt="" class="img-fluid"></p><p>This layout was abandoned because I couldn‚Äôt make the transformation of <code>purple</code> view to work when transforming in <code>3D</code>.</p><p><img src="https://aleahim.com/images/cacube/08_side4_broken.png" alt="" class="img-fluid"></p><p>The solution is to add an additional <code>CATransformLayer</code> to the <code>green</code> layer, and mount the <code>purple</code> layer onto it. As explained in this blog post by Oliver Drobnik <a href="https://www.cocoanetics.com/2012/08/cubed-coreanimation-conundrum/"> Cubed CoreAnimation Conundrum.</a></p><p>But I didn‚Äôt want to lose the linearity of the solution, and I used the approach demonstrated in the mentioned WWDC session: ‚Äú2011‚Äì421 Core Animation Essentials‚Äù</p><p>They used the <code>zOrder</code> property of a layer, and so I put <code>purple</code> layer on top of the <code>red</code> layer to achieve that.</p><pre><code class="language-swift">    if number == 4 {
      view.layer.zPosition = 1
    }
</code></pre><p>As you can see in the image below, the <code>purple</code> layer is in front of the <code>red</code> layer, which is obvious when we rotate the flattened cube.</p><p><img src="https://aleahim.com/images/cacube/09_layers_zPosition.png" alt="" class="img-fluid"></p><h3>2.3. Turning the Transform On and Off</h3><p>I did take the approach that Over Drobnik did in his article: <a href="https://www.cocoanetics.com/2012/08/cubed-coreanimation-conundrum/"> Cubed CoreAnimation Conundrum </a>, and used it like this:</p><pre><code class="language-swift">	side4.layer?.zPosition = on ? CACube3DView.sideWidth : 1
    side1.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(1, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
    side2.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(2, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
    side3.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(3, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
    side4.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(4, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
    side5.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(5, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
    side6.layer?.transform = on ? CATransform3D.transformFor3DCubeSide(6, zWidth: CACube3DView.sideWidth)  : CATransform3DIdentity
</code></pre><h3>2.4. Transforming the Layers to Form a Cube</h3><p>I didn‚Äôt use his transform code, since he used that additional <code>CATransformLayer</code>, so it wouldn‚Äôt work. So, here‚Äôs a small extension on the <code>CATransform3D</code></p><pre><code class="language-swift">public extension CATransform3D {
  static func transformFor3DCubeSide(_ number: Int, zWidth: CGFloat) -> CATransform3D {
    
    let halfPi = CGFloat(Double.pi) / 2.0
    var trans = CATransform3DIdentity
    switch number {
      case 1:
        trans = CATransform3DMakeRotation(halfPi, 0, 1, 0)
        break
      case 2:
        trans = CATransform3DIdentity
        break
      case 3:
        trans = CATransform3DMakeRotation(-halfPi, 0, 1, 0)
        break
      case 4:
        trans = CATransform3DMakeTranslation(0, 0, zWidth)
        break
      case 5:
        trans = CATransform3DMakeRotation(-halfPi, 1, 0, 0)
        break
      case 6:
        trans = CATransform3DMakeRotation(halfPi, 1, 0, 0)
        break
      default:
        break
    }
    return trans
  }
}
</code></pre><p>I actually used the approach form that WWDC session, and also used <code>anchorPoint</code> properties of the <code>CALayer</code>.</p><h3>2.5. Positioning Cube Sides</h3><p>Here‚Äôs a little extension on <code>CGPoint</code> that returns a tuple of our cube side positions and anchor points:</p><pre><code class="language-swift">public extension CGPoint {
  static func anchorPointAndPositionForCubeSideLayer(number: Int, sideSize: CGFloat) -> (anchorPoint: CGPoint, position: CGPoint) {
    var resultAnchorPoint = CGPoint(x:0.5, y:0.5)
    var resultPosition = CGPoint(x:0.0, y:0.0)
    let halfSideSize: CGFloat = sideSize / 2.0
    switch number {
      case 1:
        resultAnchorPoint = CGPoint(x:1.0, y:0.5)
        resultPosition = CGPoint(x:-halfSideSize, y:0.0)
        break
      case 2:
        resultAnchorPoint = CGPoint(x:0.5, y:0.5)
        resultPosition = CGPoint(x:0.0, y:0.0)
        break
      case 3:
        resultAnchorPoint = CGPoint(x:0.0, y:0.5)
        resultPosition = CGPoint(x:halfSideSize, y:0.0)
        break
      case 4:
        resultAnchorPoint = CGPoint(x:0.5, y:0.5)
        resultPosition = CGPoint(x:0.0, y:0.0)
        break
      case 5:
        resultAnchorPoint = CGPoint(x:0.5, y:1.0)
        resultPosition = CGPoint(x:0.0, y:-halfSideSize)
        break
      case 6:
        resultAnchorPoint = CGPoint(x:0.5, y:0.0)
        resultPosition = CGPoint(x:0.0, y:halfSideSize)
        break
      default:
        break
    }
    return (anchorPoint: resultAnchorPoint, position: resultPosition)
  }
}
</code></pre><p>In the image below I have marked where the <code>anchor points</code> are for each layer:</p><p><img src="https://aleahim.com/images/cacube/10_anchor_points.png" alt="" class="img-fluid"></p><p>The only fallacy in the image above, is that the <code>purple</code> layer is actually above our <code>red layer</code>, but I wanted to show where those anchor points are.<br />So, the actual image looks like this, but we now don‚Äôt see the <code>red</code> layer. <img src="https://aleahim.com/images/cacube/11_anchor_points.png" alt="" class="img-fluid"></p><p>An Anchor point is a center of rotation. It determines how will the layer rotate.<br />Imagine holding a playing card with two fingers. Then try to spin the card. The anchor point of that card is where you are holding it with fingers.</p><h2>3. Responding to Gestures</h2><p>I made a small <code>GestureRecognizerView</code> to be able to respond to gestures and move, rotate and scale our layers.</p><p>It hooks-up:</p><ul><li><code>NSPanGestureRecognizer</code> and <code>UIPanGestureRecognizer</code></li><li><code>func rotate(with event: NSEvent)</code> and <code>UIRotationGestureRecognizer</code></li><li><code>NSClickGestureRecognizer</code> and <code>UITapGestureRecognizer</code></li><li><code>func magnify(with event: NSEvent)</code> and <code>UIPinchGestureRecognizer</code></li></ul><p>It then exposes all those events to the developer to use:</p><pre><code class="language-swift">public extension GestureRecognizerView {
  @objc func rotationChanged(degrees: Float) {}
  @objc func rotationChanged(radians: Float) {}
  @objc func displacementChanged(displacement: CGPoint) {}
  @objc func scaleChanged(scale: CGFloat) {}
  @objc func tapHappened() {}
}
</code></pre><h2>4. Building a Layer to hold a Cube</h2><p><code>CACube3DView</code> will hold the six layers than (can) make a cube. In order for <code>Core Animation</code> to render the transformed views in perspective, there is a property <code>sublayerTransform</code>.</p><p>You either use that property of your parent layer, or add another layer class to your layer hierarchy: <code>CATransformLayer</code>. I opted to use that.</p><pre><code class="language-swift">private(set) public lazy var transformedLayer: CALayer = {
    let l = CATransformLayer()
    l.name = "Transform Layer"
    #if os(OSX)
    l.isGeometryFlipped = true
    #endif
    return l
}()
</code></pre><p>When adding sublayers, I add them to this <code>transformedLayer</code> property, and not my view‚Äôs layer.</p><pre><code class="language-swift">func addSideSubview(_ subview: AView) {
    addSubview(subview)
    
    #if os(iOS) || os(tvOS)
    transformedLayer.addSublayer(subview.layer)
    #endif
    
    #if os(OSX)
    if let aLayer = subview.layer {
      transformedLayer.addSublayer(aLayer)
    } else {
      fatalError("`subview.layer` == `nil`")
    }
    #endif
}
</code></pre><h2>5. Perspective & Rotation</h2><p>When the app first runs it shows in perspective.<br />I made a little extension:</p><pre><code class="language-swift">public extension CATransform3D {
  static func somePerspectiveTransform() -> CATransform3D {
    var perspective = CATransform3DIdentity;
    perspective.m34 = -1.0 / 500.0;
    perspective = CATransform3DRotate(perspective, CGFloat(Double.pi) / 8, 1, 0, 0);
    perspective = CATransform3DRotate(perspective, CGFloat(Double.pi) / 8, 0, 1, 0);
    perspective = CATransform3DScale(perspective, 0.7, 0.7, 0.7)
    return perspective
  }
}
</code></pre><p>The part: <code>perspective.m34 = -1.0 / 500.0;</code> sets the perspective. The <code>.34</code> field of a matrix shows the amount of perspective distortion applied. The amount <code>500</code> is often used in examples. If it were smaller, the layers would seem very close and distorted, like a fish-eye effect.</p><p>This is the initial transform, but we want to be able to move and rotate our cube (flattened or not) with our fingers.</p><p>Here‚Äôs the code:</p><pre><code class="language-swift">public extension CATransform3D {
  
  func rotationFromDisplacement(_ displacement: CGPoint, sideWidth: CGFloat, is3D: Bool) -> CATransform3D {
    
    var currentTransform = self
    
    let totalRotation: CGFloat = sqrt(displacement.x * displacement.x + displacement.y * displacement.y)
    let angle: CGFloat = totalRotation * .pi / 180.0
    
    let xRotationFactor = displacement.x / angle
    let yRotationFactor = displacement.y / angle
    
    if is3D {
      currentTransform = CATransform3DTranslate(currentTransform, 0, 0, sideWidth / 2.0)
    }
    
    var rotationalTransform = CATransform3DRotate(currentTransform, angle,
                                                  (xRotationFactor * currentTransform.m12 - yRotationFactor * currentTransform.m11),
                                                  (xRotationFactor * currentTransform.m22 - yRotationFactor * currentTransform.m21),
                                                  (xRotationFactor * currentTransform.m32 - yRotationFactor * currentTransform.m31))
    
    if (is3D) {
      rotationalTransform = CATransform3DTranslate(rotationalTransform, 0, 0, -sideWidth / 2.0);
    }
    
    return rotationalTransform
  }
}
</code></pre><p>We call it from our pan-gesture methods</p><pre><code class="language-swift">  override func displacementChanged(displacement: CGPoint) {  
    guard !(displacement.x == 0 && displacement.y == 0) else { return }
    
    let rotationTransform = transformedLayer.sublayerTransform.rotationFromDisplacement(displacement, sideWidth: CACube3DView.sideWidth, is3D: isOn)
    transformedLayer.sublayerTransform = rotationTransform
  }
</code></pre><p>We hooked up the pan-gestures prior:</p><pre><code class="language-swift">#if os(OSX)
private func setupPanGestureRecognizer() {
    let panGR = NSPanGestureRecognizer(target: self, action: #selector(handlePanGesture(_:)))
    addGestureRecognizer(panGR)
}
@objc func handlePanGesture(_ gestureRecognizer: NSPanGestureRecognizer) {
    let displacement: CGPoint = gestureRecognizer.translation(in: self)
    handlePan(displacement: displacement, changed: gestureRecognizer.state == .changed)
}
#endif
  
#if os(iOS) || os(tvOS)
private func setupPanGestureRecognizer() {
    let panGR = UIPanGestureRecognizer(target: self, action: #selector(handlePanGesture(_:)))
    addGestureRecognizer(panGR)
}
  
@objc func handlePanGesture(_ gestureRecognizer: UIPanGestureRecognizer) {
    let displacement: CGPoint = gestureRecognizer.translation(in: self)
    
    handlePan(displacement: displacement, changed: gestureRecognizer.state == .changed)
    
    if gestureRecognizer.state == .changed {
      gestureRecognizer.setTranslation(.zero, in: self)
    }
}
#endif
</code></pre><p>We can also add a simple rotation transform for the rotation events/ gestures.</p><pre><code class="language-swift">  override func rotationChanged(radians: Float) {
    let transform = transformedLayer.sublayerTransform
    let rot = CATransform3DRotate(transform, CGFloat(radians), 0, 1, 0)
    transformedLayer.sublayerTransform = rot
  }
</code></pre><p>And scale, in all three axes:</p><pre><code class="language-swift">  override func scaleChanged(scale: CGFloat) {
    let scaleTransform = CATransform3DScale(transformedLayer.sublayerTransform, scale, scale, scale)
    transformedLayer.sublayerTransform = scaleTransform
  }
</code></pre><p>The <code>tap</code> turns on and off our 3D transform</p><pre><code class="language-swift">  override func tapHappened() {
    set3DCube(on: isOn)
  }
</code></pre><p>Here‚Äôs the 3D cube code</p><pre><code class="language-swift">  func set3DCube(on: Bool) {
    side4.layer.zPosition = on ? CACube3DView.sideWidth : 1
    side1.layer.transform = on ? CATransform3D.transformFor3DCubeSide(1, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
    side2.layer.transform = on ? CATransform3D.transformFor3DCubeSide(2, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
    side3.layer.transform = on ? CATransform3D.transformFor3DCubeSide(3, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
    side4.layer.transform = on ? CATransform3D.transformFor3DCubeSide(4, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
    side5.layer.transform = on ? CATransform3D.transformFor3DCubeSide(5, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
    side6.layer.transform = on ? CATransform3D.transformFor3DCubeSide(6, zWidth: CACube3DView.sideWidth) : CATransform3DIdentity
  }
</code></pre><p>We either set the <code>identity transform</code>, which means <code>no transform</code>, to our cube sides, or the transform appropriate for that particular side.</p><h2>6. macOS Troubles</h2><p>I suppose I need to do further investigation in how <code>macOS</code> treats layers of <code>NSView</code>, for this little experiment is not working on the <code>macOS</code>, yet.<br />Here‚Äôs how the flattened cube looks on the <code>macOS</code></p><p><img src="https://aleahim.com/images/cacube/12_cube_macOS_flat_messed_up.png" alt="" class="img-fluid"></p><p>So, the positioning of the layers is not respected.</p><p>And here is the cube in 3D:</p><p><img src="https://aleahim.com/images/cacube/13_cube_macOS_3D_messed_up.png" alt="" class="img-fluid"></p><p>I did try to force the <code>isGeometryFlipped = true</code> everywhere. Anyway this needs more work.</p><p>If you want to help with the <code>macOS</code> implementation, please, be my guest.</p><p>Here‚Äôs a link to a GitHub repo with the source code:<br /><a href="https://github.com/mihaelamj/CubeIn3DWithCoreAnimation">Core Animation 3D Cube</a></p>]]></content:encoded></item></channel></rss>
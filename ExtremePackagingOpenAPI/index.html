<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="When I first published ExtremePackaging, the goal was simple â€” to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta name="author" content="Mihaela Mihaljevic" />
    <meta name="generator" content="Ignite v0.6.0" />
    <title>From ExtremePackaging to OpenAPI Integration â€“ Mihaela's Site</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-xcode-dark.css" rel="stylesheet" data-highlight-theme="xcode-dark" />
    <link href="/css/prism-xcode-light.css" rel="stylesheet" data-highlight-theme="xcode-light" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://aleahim.com/ExtremePackagingOpenAPI" rel="canonical" />
    <script>(function() {
    function getThemePreference() {
        return localStorage.getItem('custom-theme') || 'auto';
    }

    function applyTheme(themeID) {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const lightThemeID = document.documentElement.getAttribute('data-light-theme') || 'light';
        const darkThemeID = document.documentElement.getAttribute('data-dark-theme') || 'dark';
        const actualThemeID = themeID === 'auto' ? (prefersDark ? darkThemeID : lightThemeID) : themeID;

        document.documentElement.setAttribute('data-bs-theme', actualThemeID);
        document.documentElement.setAttribute('data-theme-state', themeID);
    }

    function applySyntaxTheme() {
        const syntaxTheme = getComputedStyle(document.documentElement)
            .getPropertyValue('--syntax-highlight-theme').trim().replace(/"/g, '');

        if (!syntaxTheme) return;

        document.querySelectorAll('link[data-highlight-theme]').forEach(link => {
            link.setAttribute('disabled', 'disabled');
        });

        const themeLink = document.querySelector(`link[data-highlight-theme="${syntaxTheme}"]`);
        if (themeLink) {
            themeLink.removeAttribute('disabled');
        }
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const currentTheme = getThemePreference();
        if (currentTheme === 'auto') {
            applyTheme('auto');
            applySyntaxTheme();
        }
    });

    const savedTheme = getThemePreference();
    applyTheme(savedTheme);
    applySyntaxTheme();
})();
</script>
    <meta property="og:site_name" content="Aleahim.com" />
    <meta property="og:image" content="/images/xpackopenapi/expack_openapi.png" />
    <meta name="twitter:image" content="/images/xpackopenapi/expack_openapi.png" />
    <meta property="og:title" content="From ExtremePackaging to OpenAPI Integration" />
    <meta name="twitter:title" content="From ExtremePackaging to OpenAPI Integration" />
    <meta property="og:description" content="When I first published ExtremePackaging, the goal was simple â€” to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta name="twitter:description" content="When I first published ExtremePackaging, the goal was simple â€” to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta property="og:url" content="https://aleahim.com/ExtremePackagingOpenAPI" />
    <meta name="twitter:domain" content="aleahim.com" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:dnt" content="on" />
    <script defer src="https://cloud.umami.is/script.js" data-website-id="1ee8d39f-4184-4d60-89a3-13131860112a"></script>
  </head>
  <body class="container">
    <div style="padding-bottom: 80px">
      <header>
        <nav class="fixed-top navbar navbar-expand-md">
          <div class="container flex-wrap flex-lg-nowrap">
            <div class="me-2 me-md-auto">
              <a href="/" class="d-inline-flex align-items-center navbar-brand"><span>Aleahim</span></a>
            </div>
            <button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div id="navbarCollapse" class="collapse navbar-collapse">
              <ul class="navbar-nav mb-2 mb-md-0 col justify-content-end">
                <li class="nav-item"><a href="/home" class="nav-link text-nowrap link-primary">Home</a></li>
                <li class="nav-item"><a href="/about" class="nav-link text-nowrap link-primary">About</a></li>
                <li class="nav-item"><a href="/c-v-page" class="nav-link text-nowrap link-primary">CV</a></li>
                <li class="nav-item"><a href="/consulting" class="nav-link text-nowrap link-primary">Consulting</a></li>
              </ul>
            </div>
          </div>
        </nav>
      </header>
    </div>
    <div class="ig-main-content">
      <img src="/images/xpackopenapi/expack_openapi.png" alt="" class="img-fluid" />
      <h1>From ExtremePackaging to OpenAPI Integration</h1>
      <div class="hstack gap-1">
        <a rel="tag" href="/tags/-swift" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">[Swift</span></a>
        <a rel="tag" href="/tags/open-a-p-i" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">OpenAPI</span></a>
        <a rel="tag" href="/tags/modular-architecture" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">ModularArchitecture</span></a>
        <a rel="tag" href="/tags/extreme-packaging" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">ExtremePackaging</span></a>
        <a rel="tag" href="/tags/vapor" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">Vapor</span></a>
        <a rel="tag" href="/tags/middleware" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">Middleware</span></a>
        <a rel="tag" href="/tags/yaml-merger" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">YamlMerger]</span></a>
      </div>
      <p></p>
      <p>When I first published <a href="https://github.com/mihaelamj/ExtremePackaging">ExtremePackaging</a>, the goal was simple â€” to prove that <strong>highly modular Swift architectures</strong> can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear.</p>
      <p>But then came the next step: <em>Could this same architecture host a complete OpenAPI workflow â€” with generated clients, servers, and full middleware integration â€” without losing its elegance?</em></p>
      <p>Thatâ€™s how the new reference implementation, <strong>swift-openapi-extremepackaging-example</strong>, was born.</p>
      <hr />
      <p>The original ExtremePackaging repository introduced a clean, layered structure:</p>
      <ul>
        <li><strong>Shared packages</strong> for models and protocols</li>
        <li><strong>Independent feature modules</strong> for UI, data, and networking</li>
        <li><strong>No cross-package leaks</strong></li>
        <li><strong>Unified Xcode workspace</strong> that felt like a monolith but built like microservices</li>
      </ul>
      <p>The guiding philosophy: <em>Each feature should be an island, communicating only through well-defined contracts.</em></p>
      <p>That foundation made it ideal for integrating OpenAPI-generated code â€” which naturally fits into modular boundaries like <code>SharedApiModels</code>, <code>ApiClient</code>, and <code>ApiServer</code>.</p>
      <hr />
      <h2>ğŸš€ Evolving Toward OpenAPI</h2>
      <p>The OpenAPI version added an entire new layer of automation and functionality â€” transforming a static architecture into a <strong>living, self-describing API ecosystem</strong>.</p>
      <h3>1. OpenAPI Schema &amp; Code Generation</h3>
      <p>At the heart of the project is the <strong>OpenAPI specification (<code>openapi.yaml</code>)</strong> â€” defining endpoints, models, and responses for a DummyJSON-compatible API.</p>
      <p>Newly introduced elements:</p>
      <ul>
        <li>ğŸ§± Full schema definitions for <code>Users</code>, <code>Posts</code>, <code>Products</code>, <code>Todos</code>, and <code>Carts</code></li>
        <li>ğŸ§© Error schemas (404, validation, authentication)</li>
        <li>âš™ï¸ Integration with <strong>Swift OpenAPI Generator</strong></li>
        <li>ğŸ” Automatic generation of clients, models, and server stubs</li>
        <li>ğŸ“¦ Separation of generated code into <code>SharedApiModels</code></li>
      </ul>
      <p>This turned the architecture into a self-contained API ecosystem â€” one that can <strong>generate, serve, and consume</strong> its own endpoints.</p>
      <hr />
      <h3>2. API Server Implementation</h3>
      <p>A complete <strong>Vapor-based local server</strong> (<code>ApiServer</code>) was added to simulate real-world backend behavior:</p>
      <ul>
        <li>17 endpoints fully implemented from the OpenAPI spec</li>
        <li>Realistic mock data mirroring DummyJSON</li>
        <li>Pagination and validation logic</li>
        <li>Centralized error responses</li>
        <li>ğŸ–¥ï¸ Prefixed logging for easy tracing in the console</li>
      </ul>
      <p>The server runs locally at <code>http://localhost:8080</code>, serving as both a mock backend and a test harness for the generated client.</p>
      <hr />
      <h3>3. Enhanced API Client Architecture</h3>
      <p>The client evolved from a simple abstraction into a <strong>fully concurrent, actor-based networking layer</strong>.</p>
      <h4>Highlights</h4>
      <ul>
        <li><code>ApiClient</code> actor manages shared state safely across async contexts</li>
        <li>Middleware chain introduced: <strong>Logging â†’ Authentication â†’ Correction</strong></li>
        <li>Runtime environment switching between <code>.production</code>, <code>.local</code>, and <code>.mock</code></li>
        <li>Shared singleton <code>ApiClientState</code> stores token, settings, and preferences</li>
      </ul>
      <p>Example flow:</p>
      <pre><code class="language-swift">try await ApiClient.initializeShared(environment: .production)
let client = ApiClient.shared!
let auth = try await client.login(username: "emilys", password: "emilyspass")
await ApiClient.setToken(auth.accessToken)
let users = try await client.getUsers(limit: 10)
</code></pre>
      <p>A clear separation between environment configuration and runtime state ensures deterministic, thread-safe behavior.</p>
      <hr />
      <h3>4. Middleware Integration</h3>
      <p>The client leverages two reusable middlewares from sibling packages:</p>
      <ul>
        <li><strong><a href="https://github.com/mihaelamj/OpenAPILoggingMiddleware">OpenAPILoggingMiddleware</a></strong><br />Provides structured, console + JSON logging with full request/response capture.</li>
        <li><strong><a href="https://github.com/mihaelamj/BearerTokenAuthMiddleware">BearerTokenAuthMiddleware</a></strong><br />Manages JWT token injection with a concurrency-safe actor and public operation rules.</li>
      </ul>
      <p>Together, they demonstrate the power of <strong>middleware chaining</strong> in OpenAPI Runtime â€” clean, modular extensions without inheritance or global state.</p>
      <hr />
      <h3>5. YAMLMerger â€” The Key to Structured API Specs</h3>
      <p>The project uses <strong><a href="https://github.com/mihaelamj/YamlMerger">YamlMerger</a></strong> â€” a Swift package that merges multiple YAML files into a single combined OpenAPI specification.<br />If your project doesnâ€™t already include an <code>openapi.yaml</code>, YamlMerger ensures you have one â€” and helps you maintain a <strong>structured, predictable folder layout</strong> under <code>Tests/</code> or <code>Sources/SharedApiModels/schemas/</code>.</p>
      <h4>ğŸ§  Why It Must Be Copied into the Project</h4>
      <p>YamlMerger cannot simply be added as a SwiftPM dependency for build-time merging because of <strong>SPMâ€™s read-only resolution model</strong>:</p>
      <ol>
        <li>Swift Package Manager stores dependencies in a <strong>cached, read-only</strong> location (<code>.build/checkouts/</code>).</li>
        <li>The OpenAPI generator, however, needs <strong>write access</strong> to output the merged <code>openapi.yaml</code> file directly into your source tree.</li>
        <li>SPM build scripts are not allowed to write to source folders outside their sandboxed build directory.</li>
      </ol>
      <p>âœ… <strong>Solution:</strong> Copy the YamlMerger executable directly into your project (e.g. <code>Tools/YamlMerger/</code>) and call it from a pre-build script or CI pipeline.<br />This guarantees write permissions and makes the tool available to everyone checking out the repo.</p>
      <h4>ğŸ§© What It Does</h4>
      <p>YamlMerger scans subdirectories (01 â†’ 08) and merges YAML fragments in deterministic order:</p>
      <ol>
        <li>Folders are processed numerically.</li>
        <li><code>__*.yaml</code> files merge first within each folder.</li>
        <li>Remaining files merge alphabetically.</li>
        <li>The final output is a complete OpenAPI spec, suitable for Swift OpenAPI Generator.</li>
      </ol>
      <h4>ğŸ§± Example Schema Layout</h4>
      <pre><code>Schema/
â”œâ”€â”€ 01_Info/
â”œâ”€â”€ 02_Servers/
â”œâ”€â”€ 03_Tags/
â”œâ”€â”€ 04_Paths/
â”œâ”€â”€ 05_Webhooks/
â”œâ”€â”€ 06_Components/
â”œâ”€â”€ 07_Security/
â””â”€â”€ 08_ExternalDocs/
</code></pre>
      <p>Each folder corresponds to a section of the OpenAPI spec, allowing multiple developers to work on different endpoints, schemas, or components without conflicts.</p>
      <h4>âš™ï¸ Typical Workflow</h4>
      <pre><code class="language-bash"># Merge schemas before build
./Tools/YamlMerger merge   --input Sources/SharedApiModels/schemas/   --output Sources/SharedApiModels/openapi.yaml
</code></pre>
      <p>You can run this manually, in a pre-build phase, or as part of CI/CD automation.</p>
      <h4>ğŸ’¡ Pro Tip</h4>
      <p>If your project starts <strong>without</strong> an <code>openapi.yaml</code>, placing schema fragments in structured folders under <code>Tests/</code> ensures your API structure remains organized â€” even before full code generation.<br />YamlMerger gives your tests (and your teammates) a <strong>shared, visual map</strong> of your APIâ€™s evolving shape.</p>
      <hr />
      <h3>6. Test Coverage Expansion</h3>
      <p>Two new test suites validate both local and production APIs:</p>
      <ul>
        <li>ğŸ§ª <code>ApiClientLocalTests.swift</code> â€” 25 tests targeting the local Vapor server</li>
        <li>ğŸŒ <code>ApiClientProductionTests.swift</code> â€” 29 integration tests against DummyJSON API</li>
      </ul>
      <p>Tests cover:</p>
      <ul>
        <li>Authentication and token persistence</li>
        <li>Pagination behavior</li>
        <li>Error responses and invalid IDs</li>
        <li>Concurrent request handling</li>
      </ul>
      <p>Together they form a <strong>54-test safety net</strong> proving both architecture and OpenAPI compliance.</p>
      <hr />
      <h2>ğŸ§  Architecture Snapshot</h2>
      <pre><code>Packages/
â”œâ”€â”€ Sources/
â”‚   â”œâ”€â”€ ApiClient/
â”‚   â”œâ”€â”€ ApiServer/
â”‚   â””â”€â”€ SharedApiModels/
â””â”€â”€ Tests/
    â””â”€â”€ ApiClientTests/
</code></pre>
      <p>Each target is self-contained â€” just like in the original ExtremePackaging â€” but now with full OpenAPI integration, client/server symmetry, and end-to-end testability.</p>
      <hr />
      <h2>âš¡ Key Improvements Over ExtremePackaging</h2>
      <table class="table">
        <thead>
          <tr>
            <th scope="col">Area</th>
            <th scope="col">Before</th>
            <th scope="col">After</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>API Definition</td>
            <td>Manual protocol layer</td>
            <td>Generated OpenAPI spec</td>
          </tr>
          <tr>
            <td>Networking</td>
            <td>Custom client</td>
            <td>Actor-based client w/ middlewares</td>
          </tr>
          <tr>
            <td>Server</td>
            <td>None</td>
            <td>Vapor mock server (17 endpoints)</td>
          </tr>
          <tr>
            <td>Authentication</td>
            <td>Static token</td>
            <td>BearerTokenAuthMiddleware</td>
          </tr>
          <tr>
            <td>Logging</td>
            <td>Simple print logs</td>
            <td>Structured OpenAPILoggingMiddleware</td>
          </tr>
          <tr>
            <td>Testing</td>
            <td>Minimal unit tests</td>
            <td>Full integration tests (54 total)</td>
          </tr>
          <tr>
            <td>Schema Management</td>
            <td>Handwritten</td>
            <td>Modular YAML + YamlMerger</td>
          </tr>
          <tr>
            <td>Tooling</td>
            <td>Swift only</td>
            <td>Swift + OpenAPI toolchain</td>
          </tr>
        </tbody>
      </table>
      <hr />
      <h2>ğŸ§­ Lessons Learned</h2>
      <ol>
        <li><strong>OpenAPI fits perfectly into modular Swift architectures</strong> â€” generated code belongs in its own layer, and SwiftPM makes that separation effortless.</li>
        <li><strong>Actors are the future of shared state</strong> â€” simple, safe, and transparent.</li>
        <li><strong>Middleware &gt; Managers</strong> â€” function composition scales better than class hierarchies.</li>
        <li><strong>Automation beats documentation</strong> â€” with OpenAPI, the spec <em>is</em> the documentation.</li>
      </ol>
      <hr />
      <h2>ğŸ’¬ Closing Thoughts</h2>
      <p>This evolution of ExtremePackaging into a full OpenAPI reference app is more than a demo â€” itâ€™s a <strong>blueprint for modular API-driven development in Swift</strong>.</p>
      <p>From YAML schemas to live servers and typed clients, everything now exists in one unified, testable ecosystem â€” powered by Appleâ€™s official OpenAPI tools and guided by the ExtremePackaging philosophy.</p>
      <p>ğŸ‘‰ Explore the project: <a href="https://github.com/mihaelamj/swift-openapi-extremepackaging-example">swift-openapi-extremepackaging-example</a></p>
      <hr />
      <p><em>â€œArchitecture should scale not by adding layers, but by removing assumptions.â€</em></p>
      <p></p>
    </div>
    <div>
      <div style="margin-bottom: 80px">
        <div class="mt-5 fs-2 vstack">
          <div class="mb-0 align-self-center hstack gap-3">
            <a target="_blank" rel="noopener noreferrer" href="https://github.com/mihaelamj" class="mb-0 align-self-center link-secondary"><i class="bi-github"></i></a>
            <a target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/mihaelamj/" class="mb-0 align-self-center link-secondary"><i class="bi-linkedin"></i></a>
          </div>
        </div>
      </div>
    </div>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>
<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="description" content="When I first published ExtremePackaging, the goal was simple ‚Äî to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta name="author" content="Mihaela Mihaljevic" />
    <meta name="generator" content="Ignite v0.6.0" />
    <title>From ExtremePackaging to OpenAPI Integration ‚Äì Mihaela's Site</title>
    <link href="/css/bootstrap.min.css" rel="stylesheet" />
    <link href="/css/prism-xcode-dark.css" rel="stylesheet" data-highlight-theme="xcode-dark" />
    <link href="/css/prism-xcode-light.css" rel="stylesheet" data-highlight-theme="xcode-light" />
    <link href="/css/prism-plugins.css" rel="stylesheet" />
    <link href="/css/bootstrap-icons.min.css" rel="stylesheet" />
    <link href="/css/ignite-core.min.css" rel="stylesheet" />
    <link href="https://aleahim.com/ExtremePackagingOpenAPI" rel="canonical" />
    <script>(function() {
    function getThemePreference() {
        return localStorage.getItem('custom-theme') || 'auto';
    }

    function applyTheme(themeID) {
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
        const lightThemeID = document.documentElement.getAttribute('data-light-theme') || 'light';
        const darkThemeID = document.documentElement.getAttribute('data-dark-theme') || 'dark';
        const actualThemeID = themeID === 'auto' ? (prefersDark ? darkThemeID : lightThemeID) : themeID;

        document.documentElement.setAttribute('data-bs-theme', actualThemeID);
        document.documentElement.setAttribute('data-theme-state', themeID);
    }

    function applySyntaxTheme() {
        const syntaxTheme = getComputedStyle(document.documentElement)
            .getPropertyValue('--syntax-highlight-theme').trim().replace(/"/g, '');

        if (!syntaxTheme) return;

        document.querySelectorAll('link[data-highlight-theme]').forEach(link => {
            link.setAttribute('disabled', 'disabled');
        });

        const themeLink = document.querySelector(`link[data-highlight-theme="${syntaxTheme}"]`);
        if (themeLink) {
            themeLink.removeAttribute('disabled');
        }
    }

    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', e => {
        const currentTheme = getThemePreference();
        if (currentTheme === 'auto') {
            applyTheme('auto');
            applySyntaxTheme();
        }
    });

    const savedTheme = getThemePreference();
    applyTheme(savedTheme);
    applySyntaxTheme();
})();
</script>
    <meta property="og:site_name" content="Aleahim.com" />
    <meta property="og:image" content="/images/xpackopenapi/expack_openapi.png" />
    <meta name="twitter:image" content="/images/xpackopenapi/expack_openapi.png" />
    <meta property="og:title" content="From ExtremePackaging to OpenAPI Integration" />
    <meta name="twitter:title" content="From ExtremePackaging to OpenAPI Integration" />
    <meta property="og:description" content="When I first published ExtremePackaging, the goal was simple ‚Äî to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta name="twitter:description" content="When I first published ExtremePackaging, the goal was simple ‚Äî to prove that highly modular Swift architectures can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear." />
    <meta property="og:url" content="https://aleahim.com/ExtremePackagingOpenAPI" />
    <meta name="twitter:domain" content="aleahim.com" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:dnt" content="on" />
    <script defer src="https://cloud.umami.is/script.js" data-website-id="1ee8d39f-4184-4d60-89a3-13131860112a"></script>
  </head>
  <body class="container">
    <div style="padding-bottom: 80px">
      <header>
        <nav class="fixed-top navbar navbar-expand-md">
          <div class="container flex-wrap flex-lg-nowrap">
            <div class="me-2 me-md-auto">
              <a href="/" class="d-inline-flex align-items-center navbar-brand"><span>Aleahim</span></a>
            </div>
            <button type="button" class="navbar-toggler btn" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation"><span class="navbar-toggler-icon"></span></button>
            <div id="navbarCollapse" class="collapse navbar-collapse">
              <ul class="navbar-nav mb-2 mb-md-0 col justify-content-end">
                <li class="nav-item"><a href="/home" class="nav-link text-nowrap link-primary">Home</a></li>
                <li class="nav-item"><a href="/about" class="nav-link text-nowrap link-primary">About</a></li>
                <li class="nav-item"><a href="/c-v-page" class="nav-link text-nowrap link-primary">CV</a></li>
                <li class="nav-item"><a href="/consulting" class="nav-link text-nowrap link-primary">Consulting</a></li>
              </ul>
            </div>
          </div>
        </nav>
      </header>
    </div>
    <div class="ig-main-content">
      <img src="/images/xpackopenapi/expack_openapi.png" alt="" class="img-fluid" />
      <h1>From ExtremePackaging to OpenAPI Integration</h1>
      <div class="hstack gap-1">
        <a rel="tag" href="/tags/-swift" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">[Swift</span></a>
        <a rel="tag" href="/tags/open-a-p-i" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">OpenAPI</span></a>
        <a rel="tag" href="/tags/modular-architecture" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">ModularArchitecture</span></a>
        <a rel="tag" href="/tags/extreme-packaging" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">ExtremePackaging</span></a>
        <a rel="tag" href="/tags/vapor" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">Vapor</span></a>
        <a rel="tag" href="/tags/middleware" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">Middleware</span></a>
        <a rel="tag" href="/tags/yaml-merger" class="fs-3 mb-0 align-self-center"><span class="badge text-bg-primary rounded-pill">YamlMerger]</span></a>
      </div>
      <p></p>
      <p>When I first published <a href="https://github.com/mihaelamj/ExtremePackaging">ExtremePackaging</a>, the goal was simple ‚Äî to prove that <strong>highly modular Swift architectures</strong> can scale across platforms while keeping build times fast, dependencies isolated, and the mental model crystal clear.</p>
      <p>But then came the next step: <em>Could this same architecture host a complete OpenAPI workflow ‚Äî with generated clients, servers, and full middleware integration ‚Äî without losing its elegance?</em></p>
      <p>That‚Äôs how the new reference implementation, <strong>swift-openapi-extremepackaging-example</strong>, was born.</p>
      <hr />
      <p>The original ExtremePackaging repository introduced a clean, layered structure:</p>
      <ul>
        <li><strong>Shared packages</strong> for models and protocols</li>
        <li><strong>Independent feature modules</strong> for UI, data, and networking</li>
        <li><strong>No cross-package leaks</strong></li>
        <li><strong>Unified Xcode workspace</strong> that felt like a monolith but built like microservices</li>
      </ul>
      <p>The guiding philosophy: <em>Each feature should be an island, communicating only through well-defined contracts.</em></p>
      <p>That foundation made it ideal for integrating OpenAPI-generated code ‚Äî which naturally fits into modular boundaries like <code>SharedApiModels</code>, <code>ApiClient</code>, and <code>ApiServer</code>.</p>
      <hr />
      <h2>üöÄ Evolving Toward OpenAPI</h2>
      <p>The OpenAPI version added an entire new layer of automation and functionality ‚Äî transforming a static architecture into a <strong>living, self-describing API ecosystem</strong>.</p>
      <h3>1. OpenAPI Schema &amp; Code Generation</h3>
      <p>At the heart of the project is the <strong>OpenAPI specification (<code>openapi.yaml</code>)</strong> ‚Äî defining endpoints, models, and responses for a DummyJSON-compatible API.</p>
      <p>Newly introduced elements:</p>
      <ul>
        <li>üß± Full schema definitions for <code>Users</code>, <code>Posts</code>, <code>Products</code>, <code>Todos</code>, and <code>Carts</code></li>
        <li>üß© Error schemas (404, validation, authentication)</li>
        <li>‚öôÔ∏è Integration with <strong>Swift OpenAPI Generator</strong></li>
        <li>üîÅ Automatic generation of clients, models, and server stubs</li>
        <li>üì¶ Separation of generated code into <code>SharedApiModels</code></li>
      </ul>
      <p>This turned the architecture into a self-contained API ecosystem ‚Äî one that can <strong>generate, serve, and consume</strong> its own endpoints.</p>
      <hr />
      <h3>2. API Server Implementation</h3>
      <p>A complete <strong>Vapor-based local server</strong> (<code>ApiServer</code>) was added to simulate real-world backend behavior:</p>
      <ul>
        <li>17 endpoints fully implemented from the OpenAPI spec</li>
        <li>Realistic mock data mirroring DummyJSON</li>
        <li>Pagination and validation logic</li>
        <li>Centralized error responses</li>
        <li>üñ•Ô∏è Prefixed logging for easy tracing in the console</li>
      </ul>
      <p>The server runs locally at <code>http://localhost:8080</code>, serving as both a mock backend and a test harness for the generated client.</p>
      <hr />
      <h3>3. Enhanced API Client Architecture</h3>
      <p>The client evolved from a simple abstraction into a <strong>fully concurrent, actor-based networking layer</strong>.</p>
      <h4>Highlights</h4>
      <ul>
        <li><code>ApiClient</code> actor manages shared state safely across async contexts</li>
        <li>Middleware chain introduced: <strong>Logging ‚Üí Authentication ‚Üí Correction</strong></li>
        <li>Runtime environment switching between <code>.production</code>, <code>.local</code>, and <code>.mock</code></li>
        <li>Shared singleton <code>ApiClientState</code> stores token, settings, and preferences</li>
      </ul>
      <p>Example flow:</p>
      <pre><code class="language-swift">try await ApiClient.initializeShared(environment: .production)
let client = ApiClient.shared!
let auth = try await client.login(username: "emilys", password: "emilyspass")
await ApiClient.setToken(auth.accessToken)
let users = try await client.getUsers(limit: 10)
</code></pre>
      <p>A clear separation between environment configuration and runtime state ensures deterministic, thread-safe behavior.</p>
      <hr />
      <h3>4. Middleware Integration</h3>
      <p>The client leverages two reusable middlewares from sibling packages:</p>
      <ul>
        <li><strong><a href="https://github.com/mihaelamj/OpenAPILoggingMiddleware">OpenAPILoggingMiddleware</a></strong><br />Provides structured, console + JSON logging with full request/response capture.</li>
        <li><strong><a href="https://github.com/mihaelamj/BearerTokenAuthMiddleware">BearerTokenAuthMiddleware</a></strong><br />Manages JWT token injection with a concurrency-safe actor and public operation rules.</li>
      </ul>
      <p>Together, they demonstrate the power of <strong>middleware chaining</strong> in OpenAPI Runtime ‚Äî clean, modular extensions without inheritance or global state.</p>
      <hr />
      <h3>5. YAMLMerger ‚Äî The Key to Structured API Specs</h3>
      <p>The project uses <strong><a href="https://github.com/mihaelamj/YamlMerger">YamlMerger</a></strong> ‚Äî a Swift package that merges multiple YAML files into a single combined OpenAPI specification.<br />If your project doesn‚Äôt already include an <code>openapi.yaml</code>, YamlMerger ensures you have one ‚Äî and helps you maintain a <strong>structured, predictable folder layout</strong> under <code>Tests/</code> or <code>Sources/SharedApiModels/schemas/</code>.</p>
      <h4>üß† Why It Must Be Copied into the Project</h4>
      <p>YamlMerger cannot simply be added as a SwiftPM dependency for build-time merging because of <strong>SPM‚Äôs read-only resolution model</strong>:</p>
      <ol>
        <li>Swift Package Manager stores dependencies in a <strong>cached, read-only</strong> location (<code>.build/checkouts/</code>).</li>
        <li>The OpenAPI generator, however, needs <strong>write access</strong> to output the merged <code>openapi.yaml</code> file directly into your source tree.</li>
        <li>SPM build scripts are not allowed to write to source folders outside their sandboxed build directory.</li>
      </ol>
      <p>‚úÖ <strong>Solution:</strong> Copy the YamlMerger executable directly into your project (e.g. <code>Tools/YamlMerger/</code>) and call it from a pre-build script or CI pipeline.<br />This guarantees write permissions and makes the tool available to everyone checking out the repo.</p>
      <h4>üß© What It Does</h4>
      <p>YamlMerger scans subdirectories (01 ‚Üí 08) and merges YAML fragments in deterministic order:</p>
      <ol>
        <li>Folders are processed numerically.</li>
        <li><code>__*.yaml</code> files merge first within each folder.</li>
        <li>Remaining files merge alphabetically.</li>
        <li>The final output is a complete OpenAPI spec, suitable for Swift OpenAPI Generator.</li>
      </ol>
      <h4>üß± Example Schema Layout</h4>
      <pre><code>Schema/
‚îú‚îÄ‚îÄ 01_Info/
‚îú‚îÄ‚îÄ 02_Servers/
‚îú‚îÄ‚îÄ 03_Tags/
‚îú‚îÄ‚îÄ 04_Paths/
‚îú‚îÄ‚îÄ 05_Webhooks/
‚îú‚îÄ‚îÄ 06_Components/
‚îú‚îÄ‚îÄ 07_Security/
‚îî‚îÄ‚îÄ 08_ExternalDocs/
</code></pre>
      <p>Each folder corresponds to a section of the OpenAPI spec, allowing multiple developers to work on different endpoints, schemas, or components without conflicts.</p>
      <h4>‚öôÔ∏è Typical Workflow</h4>
      <pre><code class="language-bash"># Merge schemas before build
./Tools/YamlMerger merge   --input Sources/SharedApiModels/schemas/   --output Sources/SharedApiModels/openapi.yaml
</code></pre>
      <p>You can run this manually, in a pre-build phase, or as part of CI/CD automation.</p>
      <h4>üí° Pro Tip</h4>
      <p>If your project starts <strong>without</strong> an <code>openapi.yaml</code>, placing schema fragments in structured folders under <code>Tests/</code> ensures your API structure remains organized ‚Äî even before full code generation.<br />YamlMerger gives your tests (and your teammates) a <strong>shared, visual map</strong> of your API‚Äôs evolving shape.</p>
      <hr />
      <h3>6. Test Coverage Expansion</h3>
      <p>Two new test suites validate both local and production APIs:</p>
      <ul>
        <li>üß™ <code>ApiClientLocalTests.swift</code> ‚Äî 25 tests targeting the local Vapor server</li>
        <li>üåê <code>ApiClientProductionTests.swift</code> ‚Äî 29 integration tests against DummyJSON API</li>
      </ul>
      <p>Tests cover:</p>
      <ul>
        <li>Authentication and token persistence</li>
        <li>Pagination behavior</li>
        <li>Error responses and invalid IDs</li>
        <li>Concurrent request handling</li>
      </ul>
      <p>Together they form a <strong>54-test safety net</strong> proving both architecture and OpenAPI compliance.</p>
      <hr />
      <h2>üß† Architecture Snapshot</h2>
      <pre><code>Packages/
‚îú‚îÄ‚îÄ Sources/
‚îÇ   ‚îú‚îÄ‚îÄ ApiClient/
‚îÇ   ‚îú‚îÄ‚îÄ ApiServer/
‚îÇ   ‚îî‚îÄ‚îÄ SharedApiModels/
‚îî‚îÄ‚îÄ Tests/
    ‚îî‚îÄ‚îÄ ApiClientTests/
</code></pre>
      <p>Each target is self-contained ‚Äî just like in the original ExtremePackaging ‚Äî but now with full OpenAPI integration, client/server symmetry, and end-to-end testability.</p>
      <hr />
      <h2>‚ö° Key Improvements Over ExtremePackaging</h2>
      <table class="table">
        <thead>
          <tr>
            <th scope="col">Area</th>
            <th scope="col">Before</th>
            <th scope="col">After</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>API Definition</td>
            <td>Manual protocol layer</td>
            <td>Generated OpenAPI spec</td>
          </tr>
          <tr>
            <td>Networking</td>
            <td>Custom client</td>
            <td>Actor-based client w/ middlewares</td>
          </tr>
          <tr>
            <td>Server</td>
            <td>None</td>
            <td>Vapor mock server (17 endpoints)</td>
          </tr>
          <tr>
            <td>Authentication</td>
            <td>Static token</td>
            <td>BearerTokenAuthMiddleware</td>
          </tr>
          <tr>
            <td>Logging</td>
            <td>Simple print logs</td>
            <td>Structured OpenAPILoggingMiddleware</td>
          </tr>
          <tr>
            <td>Testing</td>
            <td>Minimal unit tests</td>
            <td>Full integration tests (54 total)</td>
          </tr>
          <tr>
            <td>Schema Management</td>
            <td>Handwritten</td>
            <td>Modular YAML + YamlMerger</td>
          </tr>
          <tr>
            <td>Tooling</td>
            <td>Swift only</td>
            <td>Swift + OpenAPI toolchain</td>
          </tr>
        </tbody>
      </table>
      <hr />
      <h2>üß≠ Lessons Learned</h2>
      <ol>
        <li><strong>OpenAPI fits perfectly into modular Swift architectures</strong> ‚Äî generated code belongs in its own layer, and SwiftPM makes that separation effortless.</li>
        <li><strong>Actors are the future of shared state</strong> ‚Äî simple, safe, and transparent.</li>
        <li><strong>Middleware &gt; Managers</strong> ‚Äî function composition scales better than class hierarchies.</li>
        <li><strong>Automation beats documentation</strong> ‚Äî with OpenAPI, the spec <em>is</em> the documentation.</li>
      </ol>
      <hr />
      <h2>üí¨ Closing Thoughts</h2>
      <p>This evolution of ExtremePackaging into a full OpenAPI reference app is more than a demo ‚Äî it‚Äôs a <strong>blueprint for modular API-driven development in Swift</strong>.</p>
      <p>From YAML schemas to live servers and typed clients, everything now exists in one unified, testable ecosystem ‚Äî powered by Apple‚Äôs official OpenAPI tools and guided by the ExtremePackaging philosophy.</p>
      <p>üëâ Explore the project: <a href="https://github.com/mihaelamj/swift-openapi-extremepackaging-example">swift-openapi-extremepackaging-example</a></p>
      <hr />
      <p><em>‚ÄúArchitecture should scale not by adding layers, but by removing assumptions.‚Äù</em></p>
      <p></p>
    </div>
    <div>
      <div style="margin-bottom: 80px">
        <div class="mt-5 fs-2 vstack">
          <div class="mb-0 align-self-center hstack gap-3">
            <a target="_blank" rel="noopener noreferrer" href="https://github.com/mihaelamj" class="mb-0 align-self-center link-secondary"><i class="bi-github"></i></a>
            <a target="_blank" rel="noopener noreferrer" href="https://www.linkedin.com/in/mihaelamj/" class="mb-0 align-self-center link-secondary"><i class="bi-linkedin"></i></a>
          </div>
        </div>
      </div>
    </div>
    <script src="/js/bootstrap.bundle.min.js"></script>
    <script src="/js/syntax-highlighting.js"></script>
    <script src="/js/ignite-core.js"></script>
  </body>
</html>